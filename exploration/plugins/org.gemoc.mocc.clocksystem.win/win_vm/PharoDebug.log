THERE_BE_DRAGONS_HERE
==== Startup Error: MessageNotUnderstood: receiver of "," is nil
12 November 2015 12:20:38.517684 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

UndefinedObject(Object)>>doesNotUnderstand: #,
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	, nil
		exception: 	MessageNotUnderstood: receiver of "," is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr;
			nextPutAll: 'ERROR' ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: r...etc...
	Arguments and temporary variables: 
		anArg: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
	Receiver's instance variables: 
		outerContext: 	ClockSystem4GeMoC class>>explore:resultIn:
		startpc: 	495
		numArgs: 	0


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
		value: 	nil
	Receiver's instance variables: 
		sender: 	ClockSystem4GeMoC class>>explore:resultIn:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProdu...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
	Receiver's instance variables: 
		sender: 	ClockSystem4GeMoC class>>explore:resultIn:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProdu...etc...


MessageNotUnderstood(Exception)>>signal
	Receiver: MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {execut...etc...
		signalContext: 	MessageNotUnderstood(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		message: 	unconstrainedClockAutomata
		receiver: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {execut...etc...
		reachedDefaultHandler: 	false


ClockRelation(Object)>>doesNotUnderstand: #unconstrainedClockAutomata
	Receiver: library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {executeB1. executeB2} const...etc...
	Arguments and temporary variables: 
		aMessage: 	unconstrainedClockAutomata
		exception: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
		resumeValue: 	nil
	Receiver's instance variables: 
		system: 	ClockSystem myApplication_withMoC-xSigpmlMocc
executeB1.
executeB2.
lib...etc...
		automata: 	[ :t4 :t5 :t6 :t7 :t8 :t9 :t10 :t11 :t12 :t13 :t14 :t15 :t16 | 
| t17...etc...
		clocks: 	an Array(executeB1. executeB2.)
		constants: 	#(5 2 1 1)
		variables: 	#(0 0 1 2 0 0)
		relationName: 	#ConnectorSDF_PAM_Def
		libraryName: 	#xSigpmlMocc
		isExpression: 	false
		alphabet: 	a Set(executeB1. executeB2.)


ClockCartesianProductExploration(ClockParallelComposition)>>initializeExploration
	Receiver: a ClockCartesianProductExploration
	Arguments and temporary variables: 
		initialConfiguration: 	nil
	Receiver's instance variables: 
		model: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {executeB1...etc...
		clocks: 	an OrderedCollection(executeB1. executeB2.)
		automata: 	nil
		graph: 	a ClockConfigurationGraph
		known: 	nil
		toSee: 	nil
		satSolver: 	nil
		cartesianProductInstance: 	a CartesianProduct


ClockCartesianProductExploration(ClockParallelComposition)>>exploreModel
	Receiver: a ClockCartesianProductExploration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {executeB1...etc...
		clocks: 	an OrderedCollection(executeB1. executeB2.)
		automata: 	nil
		graph: 	a ClockConfigurationGraph
		known: 	nil
		toSee: 	nil
		satSolver: 	nil
		cartesianProductInstance: 	a CartesianProduct


ClockCartesianProductExploration class(ClockParallelComposition class)>>exploreModel:
	Receiver: ClockCartesianProductExploration
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
	Receiver's instance variables: 
		superclass: 	ClockParallelComposition
		methodDict: 	a MethodDictionary(#initialize->ClockCartesianProductExploration>>#...etc...
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#(#cartesianProductInstance)
		organization: 	a ClassOrganization
		subclasses: 	{ClockCartesianProductBDDExploration}
		name: 	#ClockCartesianProductExploration
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Composition'
		traitComposition: 	{}
		localSelectors: 	nil


[ result := ClockCartesianProductExploration exploreModel: aClockSystem ] in [ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


Time class>>microsecondsToRun:
	Receiver: Time
	Arguments and temporary variables: 
		timedBlock: 	[ result := ClockCartesianProductExploration exploreModel: aClockSy...etc...
		initialMicroseconds: 	3624780038377684
	Receiver's instance variables: 
		superclass: 	Magnitude
		methodDict: 	a MethodDictionary(#<->Time>>#< #=->Time>>#= #addSeconds:->Time>>#a...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#('seconds' 'nanos')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Time
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection(ChronologyConstants)
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Chronology'
		traitComposition: 	{}
		localSelectors: 	nil


Time class>>millisecondsToRun:
	Receiver: Time
	Arguments and temporary variables: 
		timedBlock: 	[ result := ClockCartesianProductExploration exploreModel: aClockSy...etc...
	Receiver's instance variables: 
		superclass: 	Magnitude
		methodDict: 	a MethodDictionary(#<->Time>>#< #=->Time>>#= #addSeconds:->Time>>#a...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#('seconds' 'nanos')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Time
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection(ChronologyConstants)
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Chronology'
		traitComposition: 	{}
		localSelectors: 	nil


[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>on:do:
	Receiver: [ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration explore...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileSt...etc...
	Receiver's instance variables: 
		outerContext: 	ClockSystem4GeMoC class>>explore:resultIn:
		startpc: 	186
		numArgs: 	0


ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	stream := 'C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler(AbstractCompiler)>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\Si...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	stream := 'C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkImage>>evaluate:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		aString: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection()
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aStream: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		exceptionClassToUse: 	OCSemanticWarning
		result: 	nil
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


BlockClosure>>on:do:
	Receiver: [ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdou...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :error | self handleError: error ]
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		startpc: 	110
		numArgs: 	0


EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		result: 	nil
		aStream: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		exceptionClassToUse: 	OCSemanticWarning
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>evaluateArguments
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		argumentString: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>activate
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	STCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->EvaluateCommandLineHandler>>#activate...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#EvaluateCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImport-CommandLineHandlers'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(EvaluateCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


NonInteractiveUIManager(UIManager)>>defer:
	Receiver: a NonInteractiveUIManager
	Arguments and temporary variables: 
		aBlock: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		doNotQuitOnRestart: 	false
		uiManager: 	a MorphicUIManager


PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #,
[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr;
			nextPutAll: 'ERROR' ] ] in ClockSystem4GeMoC class>>explore:resultIn:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
MessageNotUnderstood(Exception)>>signal
ClockRelation(Object)>>doesNotUnderstand: #unconstrainedClockAutomata
ClockCartesianProductExploration(ClockParallelComposition)>>initializeExploration
ClockCartesianProductExploration(ClockParallelComposition)>>exploreModel
ClockCartesianProductExploration class(ClockParallelComposition class)>>exploreModel:
[ result := ClockCartesianProductExploration exploreModel: aClockSystem ] in [ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
Time class>>microsecondsToRun:
Time class>>millisecondsToRun:
[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
BlockClosure>>on:do:
ClockSystem4GeMoC class>>explore:resultIn:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
OpalCompiler(AbstractCompiler)>>evaluate:
SmalltalkImage>>evaluate:
[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
BlockClosure>>on:do:
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
NonInteractiveUIManager(UIManager)>>defer:
PharoCommandLineHandler class>>activateWith:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aCommandLinehandler activateWith: commandLine ] in BasicCommandLineHandler>>activateSubCommand:
BlockClosure>>on:do:
BasicCommandLineHandler>>activateSubCommand:
BasicCommandLineHandler>>handleSubcommand
BasicCommandLineHandler>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in BasicCommandLineHandler>>activate
BlockClosure>>on:do:
BasicCommandLineHandler>>activate
[ self new activate ] in BasicCommandLineHandler class>>startUp:
BlockClosure>>cull:
[ action cull: resuming ] in SmalltalkImage>>executeDeferredStartupActions:
BlockClosure>>on:do:
SmalltalkImage>>logStartUpErrorDuring:into:tryDebugger:
SmalltalkImage>>executeDeferredStartupActions:
SmalltalkImage>>startupImage:snapshotWorked:
SmalltalkImage>>snapshot:andQuit:
[ Smalltalk snapshot: true andQuit: false ] in WorldState class>>saveSession
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
WorldState class>>saveSession
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got startup errors: 
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
    MessageNotUnderstood: receiver of "," is nil
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
==== Startup Error: MessageNotUnderstood: receiver of "," is nil
12 November 2015 12:24:11.119957 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

UndefinedObject(Object)>>doesNotUnderstand: #,
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	, nil
		exception: 	MessageNotUnderstood: receiver of "," is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr;
			nextPutAll: 'ERROR' ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: r...etc...
	Arguments and temporary variables: 
		anArg: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
	Receiver's instance variables: 
		outerContext: 	ClockSystem4GeMoC class>>explore:resultIn:
		startpc: 	495
		numArgs: 	0


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
		value: 	nil
	Receiver's instance variables: 
		sender: 	ClockSystem4GeMoC class>>explore:resultIn:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProdu...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
	Receiver's instance variables: 
		sender: 	ClockSystem4GeMoC class>>explore:resultIn:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProdu...etc...


MessageNotUnderstood(Exception)>>signal
	Receiver: MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {execut...etc...
		signalContext: 	MessageNotUnderstood(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		message: 	unconstrainedClockAutomata
		receiver: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {execut...etc...
		reachedDefaultHandler: 	false


ClockRelation(Object)>>doesNotUnderstand: #unconstrainedClockAutomata
	Receiver: library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {executeB1. executeB2} const...etc...
	Arguments and temporary variables: 
		aMessage: 	unconstrainedClockAutomata
		exception: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
		resumeValue: 	nil
	Receiver's instance variables: 
		system: 	ClockSystem myApplication_withMoC-xSigpmlMocc
executeB1.
executeB2.
lib...etc...
		automata: 	[ :t4 :t5 :t6 :t7 :t8 :t9 :t10 :t11 :t12 :t13 :t14 :t15 :t16 | 
| t17...etc...
		clocks: 	an Array(executeB1. executeB2.)
		constants: 	#(5 2 1 1)
		variables: 	#(0 0 1 2 0 0)
		relationName: 	#ConnectorSDF_PAM_Def
		libraryName: 	#xSigpmlMocc
		isExpression: 	false
		alphabet: 	a Set(executeB1. executeB2.)


ClockCartesianProductExploration(ClockParallelComposition)>>initializeExploration
	Receiver: a ClockCartesianProductExploration
	Arguments and temporary variables: 
		initialConfiguration: 	nil
	Receiver's instance variables: 
		model: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {executeB1...etc...
		clocks: 	an OrderedCollection(executeB1. executeB2.)
		automata: 	nil
		graph: 	a ClockConfigurationGraph
		known: 	nil
		toSee: 	nil
		satSolver: 	nil
		cartesianProductInstance: 	a CartesianProduct


ClockCartesianProductExploration(ClockParallelComposition)>>exploreModel
	Receiver: a ClockCartesianProductExploration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {executeB1...etc...
		clocks: 	an OrderedCollection(executeB1. executeB2.)
		automata: 	nil
		graph: 	a ClockConfigurationGraph
		known: 	nil
		toSee: 	nil
		satSolver: 	nil
		cartesianProductInstance: 	a CartesianProduct


ClockCartesianProductExploration class(ClockParallelComposition class)>>exploreModel:
	Receiver: ClockCartesianProductExploration
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
	Receiver's instance variables: 
		superclass: 	ClockParallelComposition
		methodDict: 	a MethodDictionary(#initialize->ClockCartesianProductExploration>>#...etc...
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#(#cartesianProductInstance)
		organization: 	a ClassOrganization
		subclasses: 	{ClockCartesianProductBDDExploration}
		name: 	#ClockCartesianProductExploration
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Composition'
		traitComposition: 	{}
		localSelectors: 	nil


[ result := ClockCartesianProductExploration exploreModel: aClockSystem ] in [ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


Time class>>microsecondsToRun:
	Receiver: Time
	Arguments and temporary variables: 
		timedBlock: 	[ result := ClockCartesianProductExploration exploreModel: aClockSy...etc...
		initialMicroseconds: 	3624780251009957
	Receiver's instance variables: 
		superclass: 	Magnitude
		methodDict: 	a MethodDictionary(#<->Time>>#< #=->Time>>#= #addSeconds:->Time>>#a...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#('seconds' 'nanos')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Time
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection(ChronologyConstants)
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Chronology'
		traitComposition: 	{}
		localSelectors: 	nil


Time class>>millisecondsToRun:
	Receiver: Time
	Arguments and temporary variables: 
		timedBlock: 	[ result := ClockCartesianProductExploration exploreModel: aClockSy...etc...
	Receiver's instance variables: 
		superclass: 	Magnitude
		methodDict: 	a MethodDictionary(#<->Time>>#< #=->Time>>#= #addSeconds:->Time>>#a...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#('seconds' 'nanos')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Time
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection(ChronologyConstants)
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Chronology'
		traitComposition: 	{}
		localSelectors: 	nil


[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>on:do:
	Receiver: [ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration explore...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileSt...etc...
	Receiver's instance variables: 
		outerContext: 	ClockSystem4GeMoC class>>explore:resultIn:
		startpc: 	186
		numArgs: 	0


ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	stream := 'C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler(AbstractCompiler)>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\Si...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	stream := 'C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkImage>>evaluate:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		aString: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection()
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aStream: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		exceptionClassToUse: 	OCSemanticWarning
		result: 	nil
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


BlockClosure>>on:do:
	Receiver: [ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdou...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :error | self handleError: error ]
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		startpc: 	110
		numArgs: 	0


EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		result: 	nil
		aStream: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		exceptionClassToUse: 	OCSemanticWarning
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>evaluateArguments
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		argumentString: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>activate
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	STCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->EvaluateCommandLineHandler>>#activate...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#EvaluateCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImport-CommandLineHandlers'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(EvaluateCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


NonInteractiveUIManager(UIManager)>>defer:
	Receiver: a NonInteractiveUIManager
	Arguments and temporary variables: 
		aBlock: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		doNotQuitOnRestart: 	false
		uiManager: 	a MorphicUIManager


PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #,
[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr;
			nextPutAll: 'ERROR' ] ] in ClockSystem4GeMoC class>>explore:resultIn:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
MessageNotUnderstood(Exception)>>signal
ClockRelation(Object)>>doesNotUnderstand: #unconstrainedClockAutomata
ClockCartesianProductExploration(ClockParallelComposition)>>initializeExploration
ClockCartesianProductExploration(ClockParallelComposition)>>exploreModel
ClockCartesianProductExploration class(ClockParallelComposition class)>>exploreModel:
[ result := ClockCartesianProductExploration exploreModel: aClockSystem ] in [ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
Time class>>microsecondsToRun:
Time class>>millisecondsToRun:
[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
BlockClosure>>on:do:
ClockSystem4GeMoC class>>explore:resultIn:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
OpalCompiler(AbstractCompiler)>>evaluate:
SmalltalkImage>>evaluate:
[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
BlockClosure>>on:do:
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
NonInteractiveUIManager(UIManager)>>defer:
PharoCommandLineHandler class>>activateWith:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aCommandLinehandler activateWith: commandLine ] in BasicCommandLineHandler>>activateSubCommand:
BlockClosure>>on:do:
BasicCommandLineHandler>>activateSubCommand:
BasicCommandLineHandler>>handleSubcommand
BasicCommandLineHandler>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in BasicCommandLineHandler>>activate
BlockClosure>>on:do:
BasicCommandLineHandler>>activate
[ self new activate ] in BasicCommandLineHandler class>>startUp:
BlockClosure>>cull:
[ action cull: resuming ] in SmalltalkImage>>executeDeferredStartupActions:
BlockClosure>>on:do:
SmalltalkImage>>logStartUpErrorDuring:into:tryDebugger:
SmalltalkImage>>executeDeferredStartupActions:
SmalltalkImage>>startupImage:snapshotWorked:
SmalltalkImage>>snapshot:andQuit:
[ Smalltalk snapshot: true andQuit: false ] in WorldState class>>saveSession
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
WorldState class>>saveSession
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got startup errors: 
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
    MessageNotUnderstood: receiver of "," is nil
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
==== Startup Error: MessageNotUnderstood: receiver of "," is nil
12 November 2015 12:24:50.766888 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

UndefinedObject(Object)>>doesNotUnderstand: #,
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	, nil
		exception: 	MessageNotUnderstood: receiver of "," is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr;
			nextPutAll: 'ERROR' ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: r...etc...
	Arguments and temporary variables: 
		anArg: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
	Receiver's instance variables: 
		outerContext: 	ClockSystem4GeMoC class>>explore:resultIn:
		startpc: 	495
		numArgs: 	0


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
		value: 	nil
	Receiver's instance variables: 
		sender: 	ClockSystem4GeMoC class>>explore:resultIn:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProdu...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
	Receiver's instance variables: 
		sender: 	ClockSystem4GeMoC class>>explore:resultIn:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProdu...etc...


MessageNotUnderstood(Exception)>>signal
	Receiver: MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {execut...etc...
		signalContext: 	MessageNotUnderstood(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		message: 	unconstrainedClockAutomata
		receiver: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {execut...etc...
		reachedDefaultHandler: 	false


ClockRelation(Object)>>doesNotUnderstand: #unconstrainedClockAutomata
	Receiver: library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {executeB1. executeB2} const...etc...
	Arguments and temporary variables: 
		aMessage: 	unconstrainedClockAutomata
		exception: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
		resumeValue: 	nil
	Receiver's instance variables: 
		system: 	ClockSystem myApplication_withMoC-xSigpmlMocc
executeB1.
executeB2.
lib...etc...
		automata: 	[ :t4 :t5 :t6 :t7 :t8 :t9 :t10 :t11 :t12 :t13 :t14 :t15 :t16 | 
| t17...etc...
		clocks: 	an Array(executeB1. executeB2.)
		constants: 	#(5 2 1 1)
		variables: 	#(0 0 1 2 0 0)
		relationName: 	#ConnectorSDF_PAM_Def
		libraryName: 	#xSigpmlMocc
		isExpression: 	false
		alphabet: 	a Set(executeB1. executeB2.)


ClockCartesianProductExploration(ClockParallelComposition)>>initializeExploration
	Receiver: a ClockCartesianProductExploration
	Arguments and temporary variables: 
		initialConfiguration: 	nil
	Receiver's instance variables: 
		model: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {executeB1...etc...
		clocks: 	an OrderedCollection(executeB1. executeB2.)
		automata: 	nil
		graph: 	a ClockConfigurationGraph
		known: 	nil
		toSee: 	nil
		satSolver: 	nil
		cartesianProductInstance: 	a CartesianProduct


ClockCartesianProductExploration(ClockParallelComposition)>>exploreModel
	Receiver: a ClockCartesianProductExploration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {executeB1...etc...
		clocks: 	an OrderedCollection(executeB1. executeB2.)
		automata: 	nil
		graph: 	a ClockConfigurationGraph
		known: 	nil
		toSee: 	nil
		satSolver: 	nil
		cartesianProductInstance: 	a CartesianProduct


ClockCartesianProductExploration class(ClockParallelComposition class)>>exploreModel:
	Receiver: ClockCartesianProductExploration
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
	Receiver's instance variables: 
		superclass: 	ClockParallelComposition
		methodDict: 	a MethodDictionary(#initialize->ClockCartesianProductExploration>>#...etc...
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#(#cartesianProductInstance)
		organization: 	a ClassOrganization
		subclasses: 	{ClockCartesianProductBDDExploration}
		name: 	#ClockCartesianProductExploration
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Composition'
		traitComposition: 	{}
		localSelectors: 	nil


[ result := ClockCartesianProductExploration exploreModel: aClockSystem ] in [ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


Time class>>microsecondsToRun:
	Receiver: Time
	Arguments and temporary variables: 
		timedBlock: 	[ result := ClockCartesianProductExploration exploreModel: aClockSy...etc...
		initialMicroseconds: 	3624780290685888
	Receiver's instance variables: 
		superclass: 	Magnitude
		methodDict: 	a MethodDictionary(#<->Time>>#< #=->Time>>#= #addSeconds:->Time>>#a...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#('seconds' 'nanos')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Time
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection(ChronologyConstants)
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Chronology'
		traitComposition: 	{}
		localSelectors: 	nil


Time class>>millisecondsToRun:
	Receiver: Time
	Arguments and temporary variables: 
		timedBlock: 	[ result := ClockCartesianProductExploration exploreModel: aClockSy...etc...
	Receiver's instance variables: 
		superclass: 	Magnitude
		methodDict: 	a MethodDictionary(#<->Time>>#< #=->Time>>#= #addSeconds:->Time>>#a...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#('seconds' 'nanos')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Time
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection(ChronologyConstants)
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Chronology'
		traitComposition: 	{}
		localSelectors: 	nil


[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>on:do:
	Receiver: [ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration explore...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileSt...etc...
	Receiver's instance variables: 
		outerContext: 	ClockSystem4GeMoC class>>explore:resultIn:
		startpc: 	186
		numArgs: 	0


ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	stream := 'C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler(AbstractCompiler)>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\Si...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	stream := 'C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkImage>>evaluate:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		aString: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection()
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aStream: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		exceptionClassToUse: 	OCSemanticWarning
		result: 	nil
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


BlockClosure>>on:do:
	Receiver: [ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdou...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :error | self handleError: error ]
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		startpc: 	110
		numArgs: 	0


EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		result: 	nil
		aStream: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		exceptionClassToUse: 	OCSemanticWarning
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>evaluateArguments
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		argumentString: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>activate
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	STCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->EvaluateCommandLineHandler>>#activate...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#EvaluateCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImport-CommandLineHandlers'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(EvaluateCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


NonInteractiveUIManager(UIManager)>>defer:
	Receiver: a NonInteractiveUIManager
	Arguments and temporary variables: 
		aBlock: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		doNotQuitOnRestart: 	false
		uiManager: 	a MorphicUIManager


PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #,
[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr;
			nextPutAll: 'ERROR' ] ] in ClockSystem4GeMoC class>>explore:resultIn:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
MessageNotUnderstood(Exception)>>signal
ClockRelation(Object)>>doesNotUnderstand: #unconstrainedClockAutomata
ClockCartesianProductExploration(ClockParallelComposition)>>initializeExploration
ClockCartesianProductExploration(ClockParallelComposition)>>exploreModel
ClockCartesianProductExploration class(ClockParallelComposition class)>>exploreModel:
[ result := ClockCartesianProductExploration exploreModel: aClockSystem ] in [ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
Time class>>microsecondsToRun:
Time class>>millisecondsToRun:
[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
BlockClosure>>on:do:
ClockSystem4GeMoC class>>explore:resultIn:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
OpalCompiler(AbstractCompiler)>>evaluate:
SmalltalkImage>>evaluate:
[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
BlockClosure>>on:do:
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
NonInteractiveUIManager(UIManager)>>defer:
PharoCommandLineHandler class>>activateWith:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aCommandLinehandler activateWith: commandLine ] in BasicCommandLineHandler>>activateSubCommand:
BlockClosure>>on:do:
BasicCommandLineHandler>>activateSubCommand:
BasicCommandLineHandler>>handleSubcommand
BasicCommandLineHandler>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in BasicCommandLineHandler>>activate
BlockClosure>>on:do:
BasicCommandLineHandler>>activate
[ self new activate ] in BasicCommandLineHandler class>>startUp:
BlockClosure>>cull:
[ action cull: resuming ] in SmalltalkImage>>executeDeferredStartupActions:
BlockClosure>>on:do:
SmalltalkImage>>logStartUpErrorDuring:into:tryDebugger:
SmalltalkImage>>executeDeferredStartupActions:
SmalltalkImage>>startupImage:snapshotWorked:
SmalltalkImage>>snapshot:andQuit:
[ Smalltalk snapshot: true andQuit: false ] in WorldState class>>saveSession
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
WorldState class>>saveSession
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got startup errors: 
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
    MessageNotUnderstood: receiver of "," is nil
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
==== Startup Error: MessageNotUnderstood: receiver of "," is nil
12 November 2015 12:26:27.179919 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

UndefinedObject(Object)>>doesNotUnderstand: #,
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	, nil
		exception: 	MessageNotUnderstood: receiver of "," is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr;
			nextPutAll: 'ERROR' ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: r...etc...
	Arguments and temporary variables: 
		anArg: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
	Receiver's instance variables: 
		outerContext: 	ClockSystem4GeMoC class>>explore:resultIn:
		startpc: 	495
		numArgs: 	0


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
		value: 	nil
	Receiver's instance variables: 
		sender: 	ClockSystem4GeMoC class>>explore:resultIn:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProdu...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
	Receiver's instance variables: 
		sender: 	ClockSystem4GeMoC class>>explore:resultIn:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProdu...etc...


MessageNotUnderstood(Exception)>>signal
	Receiver: MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {execut...etc...
		signalContext: 	MessageNotUnderstood(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		message: 	unconstrainedClockAutomata
		receiver: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {execut...etc...
		reachedDefaultHandler: 	false


ClockRelation(Object)>>doesNotUnderstand: #unconstrainedClockAutomata
	Receiver: library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {executeB1. executeB2} const...etc...
	Arguments and temporary variables: 
		aMessage: 	unconstrainedClockAutomata
		exception: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
		resumeValue: 	nil
	Receiver's instance variables: 
		system: 	ClockSystem myApplication_withMoC-xSigpmlMocc
executeB1.
executeB2.
lib...etc...
		automata: 	[ :t4 :t5 :t6 :t7 :t8 :t9 :t10 :t11 :t12 :t13 :t14 :t15 :t16 | 
| t17...etc...
		clocks: 	an Array(executeB1. executeB2.)
		constants: 	#(5 2 1 1)
		variables: 	#(0 0 1 2 0 0)
		relationName: 	#ConnectorSDF_PAM_Def
		libraryName: 	#xSigpmlMocc
		isExpression: 	false
		alphabet: 	a Set(executeB1. executeB2.)


ClockCartesianProductExploration(ClockParallelComposition)>>initializeExploration
	Receiver: a ClockCartesianProductExploration
	Arguments and temporary variables: 
		initialConfiguration: 	nil
	Receiver's instance variables: 
		model: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {executeB1...etc...
		clocks: 	an OrderedCollection(executeB1. executeB2.)
		automata: 	nil
		graph: 	a ClockConfigurationGraph
		known: 	nil
		toSee: 	nil
		satSolver: 	nil
		cartesianProductInstance: 	a CartesianProduct


ClockCartesianProductExploration(ClockParallelComposition)>>exploreModel
	Receiver: a ClockCartesianProductExploration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {executeB1...etc...
		clocks: 	an OrderedCollection(executeB1. executeB2.)
		automata: 	nil
		graph: 	a ClockConfigurationGraph
		known: 	nil
		toSee: 	nil
		satSolver: 	nil
		cartesianProductInstance: 	a CartesianProduct


ClockCartesianProductExploration class(ClockParallelComposition class)>>exploreModel:
	Receiver: ClockCartesianProductExploration
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
	Receiver's instance variables: 
		superclass: 	ClockParallelComposition
		methodDict: 	a MethodDictionary(#initialize->ClockCartesianProductExploration>>#...etc...
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#(#cartesianProductInstance)
		organization: 	a ClassOrganization
		subclasses: 	{ClockCartesianProductBDDExploration}
		name: 	#ClockCartesianProductExploration
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Composition'
		traitComposition: 	{}
		localSelectors: 	nil


[ result := ClockCartesianProductExploration exploreModel: aClockSystem ] in [ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


Time class>>microsecondsToRun:
	Receiver: Time
	Arguments and temporary variables: 
		timedBlock: 	[ result := ClockCartesianProductExploration exploreModel: aClockSy...etc...
		initialMicroseconds: 	3624780387084919
	Receiver's instance variables: 
		superclass: 	Magnitude
		methodDict: 	a MethodDictionary(#<->Time>>#< #=->Time>>#= #addSeconds:->Time>>#a...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#('seconds' 'nanos')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Time
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection(ChronologyConstants)
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Chronology'
		traitComposition: 	{}
		localSelectors: 	nil


Time class>>millisecondsToRun:
	Receiver: Time
	Arguments and temporary variables: 
		timedBlock: 	[ result := ClockCartesianProductExploration exploreModel: aClockSy...etc...
	Receiver's instance variables: 
		superclass: 	Magnitude
		methodDict: 	a MethodDictionary(#<->Time>>#< #=->Time>>#= #addSeconds:->Time>>#a...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#('seconds' 'nanos')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Time
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection(ChronologyConstants)
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Chronology'
		traitComposition: 	{}
		localSelectors: 	nil


[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>on:do:
	Receiver: [ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration explore...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileSt...etc...
	Receiver's instance variables: 
		outerContext: 	ClockSystem4GeMoC class>>explore:resultIn:
		startpc: 	186
		numArgs: 	0


ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	stream := 'C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler(AbstractCompiler)>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\Si...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	stream := 'C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkImage>>evaluate:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		aString: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection()
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aStream: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		exceptionClassToUse: 	OCSemanticWarning
		result: 	nil
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


BlockClosure>>on:do:
	Receiver: [ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdou...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :error | self handleError: error ]
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		startpc: 	110
		numArgs: 	0


EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		result: 	nil
		aStream: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		exceptionClassToUse: 	OCSemanticWarning
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>evaluateArguments
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		argumentString: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>activate
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	STCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->EvaluateCommandLineHandler>>#activate...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#EvaluateCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImport-CommandLineHandlers'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(EvaluateCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


NonInteractiveUIManager(UIManager)>>defer:
	Receiver: a NonInteractiveUIManager
	Arguments and temporary variables: 
		aBlock: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		doNotQuitOnRestart: 	false
		uiManager: 	a MorphicUIManager


PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #,
[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr;
			nextPutAll: 'ERROR' ] ] in ClockSystem4GeMoC class>>explore:resultIn:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
MessageNotUnderstood(Exception)>>signal
ClockRelation(Object)>>doesNotUnderstand: #unconstrainedClockAutomata
ClockCartesianProductExploration(ClockParallelComposition)>>initializeExploration
ClockCartesianProductExploration(ClockParallelComposition)>>exploreModel
ClockCartesianProductExploration class(ClockParallelComposition class)>>exploreModel:
[ result := ClockCartesianProductExploration exploreModel: aClockSystem ] in [ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
Time class>>microsecondsToRun:
Time class>>millisecondsToRun:
[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
BlockClosure>>on:do:
ClockSystem4GeMoC class>>explore:resultIn:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
OpalCompiler(AbstractCompiler)>>evaluate:
SmalltalkImage>>evaluate:
[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
BlockClosure>>on:do:
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
NonInteractiveUIManager(UIManager)>>defer:
PharoCommandLineHandler class>>activateWith:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aCommandLinehandler activateWith: commandLine ] in BasicCommandLineHandler>>activateSubCommand:
BlockClosure>>on:do:
BasicCommandLineHandler>>activateSubCommand:
BasicCommandLineHandler>>handleSubcommand
BasicCommandLineHandler>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in BasicCommandLineHandler>>activate
BlockClosure>>on:do:
BasicCommandLineHandler>>activate
[ self new activate ] in BasicCommandLineHandler class>>startUp:
BlockClosure>>cull:
[ action cull: resuming ] in SmalltalkImage>>executeDeferredStartupActions:
BlockClosure>>on:do:
SmalltalkImage>>logStartUpErrorDuring:into:tryDebugger:
SmalltalkImage>>executeDeferredStartupActions:
SmalltalkImage>>startupImage:snapshotWorked:
SmalltalkImage>>snapshot:andQuit:
[ Smalltalk snapshot: true andQuit: false ] in WorldState class>>saveSession
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
WorldState class>>saveSession
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got startup errors: 
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
    MessageNotUnderstood: receiver of "," is nil
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
==== Startup Error: MessageNotUnderstood: receiver of "," is nil
16 November 2015 10:24:02.909216 am

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

UndefinedObject(Object)>>doesNotUnderstand: #,
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	, nil
		exception: 	MessageNotUnderstood: receiver of "," is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr;
			nextPutAll: 'ERROR' ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: r...etc...
	Arguments and temporary variables: 
		anArg: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
	Receiver's instance variables: 
		outerContext: 	ClockSystem4GeMoC class>>explore:resultIn:
		startpc: 	495
		numArgs: 	0


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
		value: 	nil
	Receiver's instance variables: 
		sender: 	ClockSystem4GeMoC class>>explore:resultIn:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProdu...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
	Receiver's instance variables: 
		sender: 	ClockSystem4GeMoC class>>explore:resultIn:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProdu...etc...


MessageNotUnderstood(Exception)>>signal
	Receiver: MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {execut...etc...
		signalContext: 	MessageNotUnderstood(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		message: 	unconstrainedClockAutomata
		receiver: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {execut...etc...
		reachedDefaultHandler: 	false


ClockRelation(Object)>>doesNotUnderstand: #unconstrainedClockAutomata
	Receiver: library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {executeB1. executeB2} const...etc...
	Arguments and temporary variables: 
		aMessage: 	unconstrainedClockAutomata
		exception: 	MessageNotUnderstood: ClockRelation>>unconstrainedClockAutomata
		resumeValue: 	nil
	Receiver's instance variables: 
		system: 	ClockSystem myApplication_withMoC-xSigpmlMocc
executeB1.
executeB2.
lib...etc...
		automata: 	[ :t4 :t5 :t6 :t7 :t8 :t9 :t10 :t11 :t12 :t13 :t14 :t15 :t16 | 
| t17...etc...
		clocks: 	an Array(executeB1. executeB2.)
		constants: 	#(5 2 1 1)
		variables: 	#(0 0 1 2 0 0)
		relationName: 	#ConnectorSDF_PAM_Def
		libraryName: 	#xSigpmlMocc
		isExpression: 	false
		alphabet: 	a Set(executeB1. executeB2.)


ClockCartesianProductExploration(ClockParallelComposition)>>initializeExploration
	Receiver: a ClockCartesianProductExploration
	Arguments and temporary variables: 
		initialConfiguration: 	nil
	Receiver's instance variables: 
		model: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {executeB1...etc...
		clocks: 	an OrderedCollection(executeB1. executeB2.)
		automata: 	nil
		graph: 	a ClockConfigurationGraph
		known: 	nil
		toSee: 	nil
		satSolver: 	nil
		cartesianProductInstance: 	a CartesianProduct


ClockCartesianProductExploration(ClockParallelComposition)>>exploreModel
	Receiver: a ClockCartesianProductExploration
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {executeB1...etc...
		clocks: 	an OrderedCollection(executeB1. executeB2.)
		automata: 	nil
		graph: 	a ClockConfigurationGraph
		known: 	nil
		toSee: 	nil
		satSolver: 	nil
		cartesianProductInstance: 	a CartesianProduct


ClockCartesianProductExploration class(ClockParallelComposition class)>>exploreModel:
	Receiver: ClockCartesianProductExploration
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
	Receiver's instance variables: 
		superclass: 	ClockParallelComposition
		methodDict: 	a MethodDictionary(#initialize->ClockCartesianProductExploration>>#...etc...
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#(#cartesianProductInstance)
		organization: 	a ClassOrganization
		subclasses: 	{ClockCartesianProductBDDExploration}
		name: 	#ClockCartesianProductExploration
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Composition'
		traitComposition: 	{}
		localSelectors: 	nil


[ result := ClockCartesianProductExploration exploreModel: aClockSystem ] in [ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


Time class>>microsecondsToRun:
	Receiver: Time
	Arguments and temporary variables: 
		timedBlock: 	[ result := ClockCartesianProductExploration exploreModel: aClockSy...etc...
		initialMicroseconds: 	3625118642723216
	Receiver's instance variables: 
		superclass: 	Magnitude
		methodDict: 	a MethodDictionary(#<->Time>>#< #=->Time>>#= #addSeconds:->Time>>#a...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#('seconds' 'nanos')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Time
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection(ChronologyConstants)
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Chronology'
		traitComposition: 	{}
		localSelectors: 	nil


Time class>>millisecondsToRun:
	Receiver: Time
	Arguments and temporary variables: 
		timedBlock: 	[ result := ClockCartesianProductExploration exploreModel: aClockSy...etc...
	Receiver's instance variables: 
		superclass: 	Magnitude
		methodDict: 	a MethodDictionary(#<->Time>>#< #=->Time>>#= #addSeconds:->Time>>#a...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#('seconds' 'nanos')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Time
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection(ChronologyConstants)
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Chronology'
		traitComposition: 	{}
		localSelectors: 	nil


[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>on:do:
	Receiver: [ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration explore...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileSt...etc...
	Receiver's instance variables: 
		outerContext: 	ClockSystem4GeMoC class>>explore:resultIn:
		startpc: 	186
		numArgs: 	0


ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		result: 	nil
		resultsPath: 	nil
		fiacreGraph: 	nil
		sysName: 	nil
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	nil
		mtxFile: 	nil
		ltsFile: 	nil
		resultFile: 	nil
		aClockSystem: 	library: #xSigpmlMocc relation: #ConnectorSDF_PAM_Def clocks: {ex...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	stream := 'C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler(AbstractCompiler)>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\Si...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	stream := 'C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkImage>>evaluate:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		aString: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection()
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aStream: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		exceptionClassToUse: 	OCSemanticWarning
		result: 	nil
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


BlockClosure>>on:do:
	Receiver: [ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdou...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :error | self handleError: error ]
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		startpc: 	110
		numArgs: 	0


EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		result: 	nil
		aStream: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlM...etc...
		exceptionClassToUse: 	OCSemanticWarning
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>evaluateArguments
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		argumentString: 	'stream := ''C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>activate
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	STCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->EvaluateCommandLineHandler>>#activate...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#EvaluateCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImport-CommandLineHandlers'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(EvaluateCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


NonInteractiveUIManager(UIManager)>>defer:
	Receiver: a NonInteractiveUIManager
	Arguments and temporary variables: 
		aBlock: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		doNotQuitOnRestart: 	false
		uiManager: 	a MorphicUIManager


PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #,
[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr;
			nextPutAll: 'ERROR' ] ] in ClockSystem4GeMoC class>>explore:resultIn:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
MessageNotUnderstood(Exception)>>signal
ClockRelation(Object)>>doesNotUnderstand: #unconstrainedClockAutomata
ClockCartesianProductExploration(ClockParallelComposition)>>initializeExploration
ClockCartesianProductExploration(ClockParallelComposition)>>exploreModel
ClockCartesianProductExploration class(ClockParallelComposition class)>>exploreModel:
[ result := ClockCartesianProductExploration exploreModel: aClockSystem ] in [ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
Time class>>microsecondsToRun:
Time class>>millisecondsToRun:
[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
BlockClosure>>on:do:
ClockSystem4GeMoC class>>explore:resultIn:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
OpalCompiler(AbstractCompiler)>>evaluate:
SmalltalkImage>>evaluate:
[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
BlockClosure>>on:do:
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
NonInteractiveUIManager(UIManager)>>defer:
PharoCommandLineHandler class>>activateWith:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aCommandLinehandler activateWith: commandLine ] in BasicCommandLineHandler>>activateSubCommand:
BlockClosure>>on:do:
BasicCommandLineHandler>>activateSubCommand:
BasicCommandLineHandler>>handleSubcommand
BasicCommandLineHandler>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in BasicCommandLineHandler>>activate
BlockClosure>>on:do:
BasicCommandLineHandler>>activate
[ self new activate ] in BasicCommandLineHandler class>>startUp:
BlockClosure>>cull:
[ action cull: resuming ] in SmalltalkImage>>executeDeferredStartupActions:
BlockClosure>>on:do:
SmalltalkImage>>logStartUpErrorDuring:into:tryDebugger:
SmalltalkImage>>executeDeferredStartupActions:
SmalltalkImage>>startupImage:snapshotWorked:
SmalltalkImage>>snapshot:andQuit:
[ Smalltalk snapshot: true andQuit: false ] in WorldState class>>saveSession
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
WorldState class>>saveSession
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got startup errors: 
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
    MessageNotUnderstood: receiver of "," is nil
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Command line handler failed
16 November 2015 3:21:44.658882 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:for:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
		aCommandLinehandler: 	a PharoCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ :exit | ^ self handleExit: exit ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>cull:
	Receiver: [ :exit | ^ self handleExit: exit ]
	Arguments and temporary variables: 
		anArg: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	73
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	Exit: Command line handler failed 1
		value: 	nil
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ ...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ ...etc...


Exit(Exception)>>signal
	Receiver: Exit: Command line handler failed 1
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Command line handler failed'
		tag: 	nil
		signaler: 	a PharoCommandLineHandler
		signalContext: 	Exit(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		status: 	1


Exit(Exception)>>signal:
	Receiver: Exit: Command line handler failed 1
	Arguments and temporary variables: 
		signalerText: 	'Command line handler failed'
	Receiver's instance variables: 
		messageText: 	'Command line handler failed'
		tag: 	nil
		signaler: 	a PharoCommandLineHandler
		signalContext: 	Exit(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		status: 	1


Exit class>>signalFailure:
	Receiver: Exit
	Arguments and temporary variables: 
		aMessage: 	'Command line handler failed'
	Receiver's instance variables: 
		superclass: 	Exception
		methodDict: 	a MethodDictionary(#defaultAction->Exit>>#defaultAction #isSuccess-...etc...
		format: 	144
		layout: 	a FixedLayout
		instanceVariables: 	#('status')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Exit
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Exceptions'
		traitComposition: 	{}
		localSelectors: 	nil


PharoCommandLineHandler(CommandLineHandler)>>exitFailure:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aMessage: 	'Command line handler failed'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(CommandLineHandler)>>exitFailure
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>error
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'Transcript'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 2 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1090574
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(19660800) a LabelMor...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1090574
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1090574
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(19660800) a LabelMor...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:for:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:
[ :exit | ^ self handleExit: exit ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
Exit(Exception)>>signal
Exit(Exception)>>signal:
Exit class>>signalFailure:
PharoCommandLineHandler(CommandLineHandler)>>exitFailure:
PharoCommandLineHandler(CommandLineHandler)>>exitFailure
PharoCommandLineHandler(BasicCommandLineHandler)>>error
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ThreadSafeTranscript>>show
16 November 2015 3:22:10.140882 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

ThreadSafeTranscript(Object)>>doesNotUnderstand: #show
	Receiver: Transcript
	Arguments and temporary variables: 
		aMessage: 	show
		exception: 	MessageNotUnderstood: ThreadSafeTranscript>>show
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		stream: 	a WriteStream
		accessSemaphore: 	a Mutex
		deferredClear: 	false
		deferredEndEntry: 	false
		stepContents: 	'
ScriptStarter did not execute a given script, since it assumes ...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'Transcript show "test"'
		itsSelection: 	a Text for 'Transcript show "test"'
		itsSelectionString: 	'Transcript show "test"'
	Receiver's instance variables: 
		ast: 	DoIt
	^ Transcript show	pt sho
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(952369152)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(952369152)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(460587008)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(952369152)
	Arguments and temporary variables: 
		editBlock: 	[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
tex...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@31)
		owner: 	a TransformWithLayoutMorph(540016640)
		submorphs: 	an Array(a RubPrimarySelectionMorph(309329920) a RubCursor(261619712...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (323485696) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(525860864)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color transparent
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(261619712)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(289406976))
		getMenuPolicy: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoPlaygroundRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(460587008)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor ...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	a FormCanvas on: DisplayScreen(976x662x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	24911
		lastStepMessage: 	nil
		lastCycleTime: 	25730
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(261619712)))
		lastAlarmTime: 	25710
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(692060160) a Sp...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	a FormCanvas on: DisplayScreen(976x662x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	24911
		lastStepMessage: 	nil
		lastCycleTime: 	25730
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(261619712)))
		lastAlarmTime: 	25710
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	a FormCanvas on: DisplayScreen(976x662x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	24911
		lastStepMessage: 	nil
		lastCycleTime: 	25730
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(261619712)))
		lastAlarmTime: 	25710
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(692060160) a Sp...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ThreadSafeTranscript(Object)>>doesNotUnderstand: #show
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ 
textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ 
textMorph textArea
	handleEdit: [ 
		textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoPlaygroundRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Command line handler failed
16 November 2015 3:23:23.147519 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:for:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
		aCommandLinehandler: 	a PharoCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ :exit | ^ self handleExit: exit ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>cull:
	Receiver: [ :exit | ^ self handleExit: exit ]
	Arguments and temporary variables: 
		anArg: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	73
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	Exit: Command line handler failed 1
		value: 	nil
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ ...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ ...etc...


Exit(Exception)>>signal
	Receiver: Exit: Command line handler failed 1
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Command line handler failed'
		tag: 	nil
		signaler: 	a PharoCommandLineHandler
		signalContext: 	Exit(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		status: 	1


Exit(Exception)>>signal:
	Receiver: Exit: Command line handler failed 1
	Arguments and temporary variables: 
		signalerText: 	'Command line handler failed'
	Receiver's instance variables: 
		messageText: 	'Command line handler failed'
		tag: 	nil
		signaler: 	a PharoCommandLineHandler
		signalContext: 	Exit(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		status: 	1


Exit class>>signalFailure:
	Receiver: Exit
	Arguments and temporary variables: 
		aMessage: 	'Command line handler failed'
	Receiver's instance variables: 
		superclass: 	Exception
		methodDict: 	a MethodDictionary(#defaultAction->Exit>>#defaultAction #isSuccess-...etc...
		format: 	144
		layout: 	a FixedLayout
		instanceVariables: 	#('status')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Exit
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Exceptions'
		traitComposition: 	{}
		localSelectors: 	nil


PharoCommandLineHandler(CommandLineHandler)>>exitFailure:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aMessage: 	'Command line handler failed'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(CommandLineHandler)>>exitFailure
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>error
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'Transcript'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 2 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1090574
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(19660800) a LabelMor...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1090574
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1090574
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(19660800) a LabelMor...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:for:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:
[ :exit | ^ self handleExit: exit ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
Exit(Exception)>>signal
Exit(Exception)>>signal:
Exit class>>signalFailure:
PharoCommandLineHandler(CommandLineHandler)>>exitFailure:
PharoCommandLineHandler(CommandLineHandler)>>exitFailure
PharoCommandLineHandler(BasicCommandLineHandler)>>error
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Command line handler failed
16 November 2015 3:24:22.08489 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:for:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
		aCommandLinehandler: 	a PharoCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ :exit | ^ self handleExit: exit ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>cull:
	Receiver: [ :exit | ^ self handleExit: exit ]
	Arguments and temporary variables: 
		anArg: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	73
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	Exit: Command line handler failed 1
		value: 	nil
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ ...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ ...etc...


Exit(Exception)>>signal
	Receiver: Exit: Command line handler failed 1
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Command line handler failed'
		tag: 	nil
		signaler: 	a PharoCommandLineHandler
		signalContext: 	Exit(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		status: 	1


Exit(Exception)>>signal:
	Receiver: Exit: Command line handler failed 1
	Arguments and temporary variables: 
		signalerText: 	'Command line handler failed'
	Receiver's instance variables: 
		messageText: 	'Command line handler failed'
		tag: 	nil
		signaler: 	a PharoCommandLineHandler
		signalContext: 	Exit(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		status: 	1


Exit class>>signalFailure:
	Receiver: Exit
	Arguments and temporary variables: 
		aMessage: 	'Command line handler failed'
	Receiver's instance variables: 
		superclass: 	Exception
		methodDict: 	a MethodDictionary(#defaultAction->Exit>>#defaultAction #isSuccess-...etc...
		format: 	144
		layout: 	a FixedLayout
		instanceVariables: 	#('status')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Exit
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Exceptions'
		traitComposition: 	{}
		localSelectors: 	nil


PharoCommandLineHandler(CommandLineHandler)>>exitFailure:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aMessage: 	'Command line handler failed'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(CommandLineHandler)>>exitFailure
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>error
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'Transcript show:''test'''
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 2 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1090574
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(19660800) a LabelMor...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1090574
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1090574
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(19660800) a LabelMor...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:for:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:
[ :exit | ^ self handleExit: exit ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
Exit(Exception)>>signal
Exit(Exception)>>signal:
Exit class>>signalFailure:
PharoCommandLineHandler(CommandLineHandler)>>exitFailure:
PharoCommandLineHandler(CommandLineHandler)>>exitFailure
PharoCommandLineHandler(BasicCommandLineHandler)>>error
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Command line handler failed
16 November 2015 3:24:32.95851 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:for:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
		aCommandLinehandler: 	a PharoCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ :exit | ^ self handleExit: exit ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>cull:
	Receiver: [ :exit | ^ self handleExit: exit ]
	Arguments and temporary variables: 
		anArg: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	73
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	Exit: Command line handler failed 1
		value: 	nil
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ ...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ ...etc...


Exit(Exception)>>signal
	Receiver: Exit: Command line handler failed 1
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Command line handler failed'
		tag: 	nil
		signaler: 	a PharoCommandLineHandler
		signalContext: 	Exit(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		status: 	1


Exit(Exception)>>signal:
	Receiver: Exit: Command line handler failed 1
	Arguments and temporary variables: 
		signalerText: 	'Command line handler failed'
	Receiver's instance variables: 
		messageText: 	'Command line handler failed'
		tag: 	nil
		signaler: 	a PharoCommandLineHandler
		signalContext: 	Exit(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		status: 	1


Exit class>>signalFailure:
	Receiver: Exit
	Arguments and temporary variables: 
		aMessage: 	'Command line handler failed'
	Receiver's instance variables: 
		superclass: 	Exception
		methodDict: 	a MethodDictionary(#defaultAction->Exit>>#defaultAction #isSuccess-...etc...
		format: 	144
		layout: 	a FixedLayout
		instanceVariables: 	#('status')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Exit
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Exceptions'
		traitComposition: 	{}
		localSelectors: 	nil


PharoCommandLineHandler(CommandLineHandler)>>exitFailure:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aMessage: 	'Command line handler failed'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(CommandLineHandler)>>exitFailure
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>error
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'Transcript'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 2 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1090574
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(19660800) a LabelMor...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1090574
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1090574
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(19660800) a LabelMor...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:for:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:
[ :exit | ^ self handleExit: exit ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
Exit(Exception)>>signal
Exit(Exception)>>signal:
Exit class>>signalFailure:
PharoCommandLineHandler(CommandLineHandler)>>exitFailure:
PharoCommandLineHandler(CommandLineHandler)>>exitFailure
PharoCommandLineHandler(BasicCommandLineHandler)>>error
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FileStream class>>foreceNewFileNamed:
16 November 2015 3:26:37.534634 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

FileStream class(Object)>>doesNotUnderstand: #foreceNewFileNamed:
	Receiver: FileStream
	Arguments and temporary variables: 
		aMessage: 	foreceNewFileNamed: 'c:/test.txt'
		exception: 	MessageNotUnderstood: FileStream class>>foreceNewFileNamed:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ FileStream foreceNewFileNamed: 'c:/test.txt'
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler(AbstractCompiler)>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'FileStream foreceNewFileNamed: ''c:/test.txt'''
	Receiver's instance variables: 
		ast: 	DoIt
	^ FileStream foreceNewFileNamed: 'c:/test.txt'
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkImage>>evaluate:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		aString: 	'FileStream foreceNewFileNamed: ''c:/test.txt'''
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection()
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aStream: 	'FileStream foreceNewFileNamed: ''c:/test.txt'''
		exceptionClassToUse: 	OCSemanticWarning
		result: 	nil
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


BlockClosure>>on:do:
	Receiver: [ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdou...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :error | self handleError: error ]
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		startpc: 	110
		numArgs: 	0


EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		result: 	nil
		aStream: 	'FileStream foreceNewFileNamed: ''c:/test.txt'''
		exceptionClassToUse: 	OCSemanticWarning
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>evaluateArguments
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		argumentString: 	'FileStream foreceNewFileNamed: ''c:/test.txt'''
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>activate
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	STCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->EvaluateCommandLineHandler>>#activate...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#EvaluateCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImport-CommandLineHandlers'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(EvaluateCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 2 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1090574
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(19660800) a LabelMor...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1090574
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1090574
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(19660800) a LabelMor...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
FileStream class(Object)>>doesNotUnderstand: #foreceNewFileNamed:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
OpalCompiler(AbstractCompiler)>>evaluate:
SmalltalkImage>>evaluate:
[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
BlockClosure>>on:do:
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FileStream class>>nextPutAll:
16 November 2015 3:28:02.156475 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

FileStream class(Object)>>doesNotUnderstand: #nextPutAll:
	Receiver: FileStream
	Arguments and temporary variables: 
		aMessage: 	nextPutAll: 'aaa'
		exception: 	MessageNotUnderstood: FileStream class>>nextPutAll:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ FileStream
		forceNewFileNamed: 'c:/test2.txt';
		nextPutAll: 'aaa...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler(AbstractCompiler)>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'FileStream forceNewFileNamed: ''c:/test2.txt''; nextPutAll:''aaa...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	^ FileStream
		forceNewFileNamed: 'c:/test2.txt';
		nextPutAll: 'aaa...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkImage>>evaluate:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		aString: 	'FileStream forceNewFileNamed: ''c:/test2.txt''; nextPutAll:''aaa'';cl...etc...
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection()
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aStream: 	'FileStream forceNewFileNamed: ''c:/test2.txt''; nextPutAll:''aaa'';cl...etc...
		exceptionClassToUse: 	OCSemanticWarning
		result: 	nil
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


BlockClosure>>on:do:
	Receiver: [ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdou...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :error | self handleError: error ]
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		startpc: 	110
		numArgs: 	0


EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		result: 	nil
		aStream: 	'FileStream forceNewFileNamed: ''c:/test2.txt''; nextPutAll:''aaa'';cl...etc...
		exceptionClassToUse: 	OCSemanticWarning
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>evaluateArguments
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		argumentString: 	'FileStream forceNewFileNamed: ''c:/test2.txt''; nextPutAll:''a...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>activate
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	STCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->EvaluateCommandLineHandler>>#activate...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#EvaluateCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImport-CommandLineHandlers'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(EvaluateCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	a FormCanvas on: DisplayScreen(976x662x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GrowlMorph(427032576))(a GrowlMorph(...etc...
		lastStepTime: 	339
		lastStepMessage: 	nil
		lastCycleTime: 	339
		alarms: 	a Heap()
		lastAlarmTime: 	339
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GrowlMorph(427032576) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	a FormCanvas on: DisplayScreen(976x662x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GrowlMorph(427032576))(a GrowlMorph(...etc...
		lastStepTime: 	339
		lastStepMessage: 	nil
		lastCycleTime: 	339
		alarms: 	a Heap()
		lastAlarmTime: 	339
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	a FormCanvas on: DisplayScreen(976x662x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GrowlMorph(427032576))(a GrowlMorph(...etc...
		lastStepTime: 	339
		lastStepMessage: 	nil
		lastCycleTime: 	339
		alarms: 	a Heap()
		lastAlarmTime: 	339
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GrowlMorph(427032576) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
FileStream class(Object)>>doesNotUnderstand: #nextPutAll:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
OpalCompiler(AbstractCompiler)>>evaluate:
SmalltalkImage>>evaluate:
[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
BlockClosure>>on:do:
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
==== Startup Error: MessageNotUnderstood: FileStream class>>run:
16 November 2015 3:32:13.689872 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

FileStream class(Object)>>doesNotUnderstand: #run:
	Receiver: FileStream
	Arguments and temporary variables: 
		aMessage: 	run: an OrderedCollection('FileStream' 'forceNewFileNamed:' '''c:/tes...etc...
		exception: 	MessageNotUnderstood: FileStream class>>run:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


ScriptStarter class>>executeRunFor:with:
	Receiver: ScriptStarter
	Arguments and temporary variables: 
		scriptClassName: 	'FileStream'
		arguments: 	an OrderedCollection('FileStream' 'forceNewFileNamed:' '''c:/test2.t...etc...
		scriptClass: 	FileStream
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ScriptStarter
		classPool: 	a Dictionary(#IsResuming->true #QuitVM->true #SafeBeforeQuit->false ...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Scripting
		traitComposition: 	{}
		localSelectors: 	nil


ScriptStarter class>>startUp
	Receiver: ScriptStarter
	Arguments and temporary variables: 
		arguments: 	an OrderedCollection('FileStream' 'forceNewFileNamed:' '''c:/test2.t...etc...
		scriptClassName: 	'FileStream'
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ScriptStarter
		classPool: 	a Dictionary(#IsResuming->true #QuitVM->true #SafeBeforeQuit->false ...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Scripting
		traitComposition: 	{}
		localSelectors: 	nil


ScriptStarter class(Behavior)>>startUp:
	Receiver: ScriptStarter
	Arguments and temporary variables: 
		resuming: 	true
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ScriptStarter
		classPool: 	a Dictionary(#IsResuming->true #QuitVM->true #SafeBeforeQuit->false ...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Scripting
		traitComposition: 	{}
		localSelectors: 	nil


ScriptStarter class>>startUp:
	Receiver: ScriptStarter
	Arguments and temporary variables: 
		resuming: 	true
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ScriptStarter
		classPool: 	a Dictionary(#IsResuming->true #QuitVM->true #SafeBeforeQuit->false ...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Scripting
		traitComposition: 	{}
		localSelectors: 	nil


[ class perform: startUpOrShutDown with: argument ] in [ :name | 
| class |
class := self at: name ifAbsent: [ nil ].
class
	ifNil: [ removals add: name ]
	ifNotNil: [ self logStartUpErrorDuring: [ class perform: startUpOrShutDown with: argument ] into: errors tryDebugger: false ] ] in SmalltalkImage>>send:toClassesNamedIn:with:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		startUpOrShutDown: 	#startUp:
		startUpOrShutDownList: 	an OrderedCollection(#SmallInteger #Delay #OSPlatform #D...etc...
		argument: 	true
		removals: 	an OrderedCollection()
		errors: 	an OrderedCollection()
		name: 	#ScriptStarter
		class: 	ScriptStarter
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection([ UIManager default inform: aStrin...etc...
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


BlockClosure>>on:do:
	Receiver: [ class perform: startUpOrShutDown with: argument ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | self logStartupError: err into: aCollection tryDebugger...etc...
	Receiver's instance variables: 
		outerContext: 	[ :name | 
| class |
class := self at: name ifAbsent: [ nil ].
cl...etc...
		startpc: 	84
		numArgs: 	0


SmalltalkImage>>logStartUpErrorDuring:into:tryDebugger:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		aBlock: 	[ class perform: startUpOrShutDown with: argument ]
		aCollection: 	an OrderedCollection()
		tryDebugger: 	false
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection([ UIManager default inform: aStrin...etc...
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


[ :name | 
| class |
class := self at: name ifAbsent: [ nil ].
class
	ifNil: [ removals add: name ]
	ifNotNil: [ self logStartUpErrorDuring: [ class perform: startUpOrShutDown with: argument ] into: errors tryDebugger: false ] ] in SmalltalkImage>>send:toClassesNamedIn:with:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		startUpOrShutDown: 	#startUp:
		startUpOrShutDownList: 	an OrderedCollection(#SmallInteger #Delay #OSPlatform #D...etc...
		argument: 	true
		removals: 	an OrderedCollection()
		errors: 	an OrderedCollection()
		name: 	#ScriptStarter
		class: 	ScriptStarter
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection([ UIManager default inform: aStrin...etc...
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


OrderedCollection>>do:
	Receiver: an OrderedCollection(#SmallInteger #Delay #OSPlatform #DisplayScreen #Cursor #InputEventFe...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :name | 
| class |
class := self at: name ifAbsent: [ nil ].
class
	i...etc...
		index: 	70
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	38
		lastIndex: 	73


SmalltalkImage>>send:toClassesNamedIn:with:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		startUpOrShutDown: 	#startUp:
		startUpOrShutDownList: 	an OrderedCollection(#SmallInteger #Delay #OSPlatform #D...etc...
		argument: 	true
		removals: 	an OrderedCollection()
		errors: 	an OrderedCollection()
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection([ UIManager default inform: aStrin...etc...
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


SmalltalkImage>>processStartUpList:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		resuming: 	true
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection([ UIManager default inform: aStrin...etc...
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


[ 
startupErrors addAll: (self processStartUpList: isNewImage).
isNewImage
	ifTrue: [ self recordStartupStamp ] ] in SmalltalkImage>>startupImage:snapshotWorked:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		isNewImage: 	true
		snapshotResult: 	true
		startupErrors: 	an OrderedCollection()
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection([ UIManager default inform: aStrin...etc...
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


BlockClosure>>ensure:
	Receiver: [ 
startupErrors addAll: (self processStartUpList: isNewImage).
isNewImage
	ifTrue: [ self...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self class default: self ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SmalltalkImage>>startupImage:snapshotWorked:
		startpc: 	112
		numArgs: 	0


MorphicUIManager(UIManager)>>boot:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		bootingFromDisk: 	true
		aBlock: 	[ 
startupErrors addAll: (self processStartUpList: isNewImage).
isNewIm...etc...
	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


SmalltalkImage>>startupImage:snapshotWorked:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		isNewImage: 	true
		snapshotResult: 	true
		startupErrors: 	an OrderedCollection()
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection([ UIManager default inform: aStrin...etc...
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


SmalltalkImage>>snapshot:andQuit:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		snapshotResult: 	true
		isNewImage: 	true
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection([ UIManager default inform: aStrin...etc...
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


[ Smalltalk snapshot: true andQuit: false ] in WorldState class>>saveSession
	Receiver: WorldState
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #addAlarm:w...etc...
		format: 	152
		layout: 	a FixedLayout
		instanceVariables: 	#('hands' 'viewBox' 'canvas' 'damageRecorder' 'stepList' 'la...etc...
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->true #DebugShowDamage->false #Deferr...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>ensure:
	Receiver: [ Smalltalk snapshot: true andQuit: false ]
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldState class>>saveSession
		startpc: 	39
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r11000000000000000000
...etc...
	Arguments and temporary variables: 
		aBlock: 	[ Smalltalk snapshot: true andQuit: false ]
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


WorldState class>>saveSession
	Receiver: WorldState
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #addAlarm:w...etc...
		format: 	152
		layout: 	a FixedLayout
		instanceVariables: 	#('hands' 'viewBox' 'canvas' 'damageRecorder' 'stepList' 'la...etc...
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->true #DebugShowDamage->false #Deferr...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil


[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(134479872)'Save'
	Arguments and temporary variables: 
		evt: 	[(78@567) mouseUp 17067694 nil]
		w: 	a WorldMorph(511705088) [world]
		selArgCount: 	0
	Receiver's instance variables: 
		bounds: 	(44.0@556.0) corner: (180.0@574.0)
		owner: 	a MenuMorph(744488960)
		submorphs: 	#()
		fullBounds: 	(44.0@556.0) corner: (180.0@574.0)
		color: 	Color black
		extension: 	a MorphExtension (165675008)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'Save'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	WorldState
		selector: 	#saveSession
		arguments: 	nil
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	nil


BlockClosure>>ensure:
	Receiver: [ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selec...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	134
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(s...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(134479872)'Save'
	Arguments and temporary variables: 
		evt: 	[(78@567) mouseUp 17067694 nil]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(44.0@556.0) corner: (180.0@574.0)
		owner: 	a MenuMorph(744488960)
		submorphs: 	#()
		fullBounds: 	(44.0@556.0) corner: (180.0@574.0)
		color: 	Color black
		extension: 	a MorphExtension (165675008)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'Save'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	WorldState
		selector: 	#saveSession
		arguments: 	nil
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(134479872)'Save'
	Arguments and temporary variables: 
		evt: 	[(78@567) mouseUp 17067694 nil]
	Receiver's instance variables: 
		bounds: 	(44.0@556.0) corner: (180.0@574.0)
		owner: 	a MenuMorph(744488960)
		submorphs: 	#()
		fullBounds: 	(44.0@556.0) corner: (180.0@574.0)
		color: 	Color black
		extension: 	a MorphExtension (165675008)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'Save'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	WorldState
		selector: 	#saveSession
		arguments: 	nil
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(134479872)'Save'
	Arguments and temporary variables: 
		anEvent: 	[(78@567) mouseUp 17067694 nil]
	Receiver's instance variables: 
		bounds: 	(44.0@556.0) corner: (180.0@574.0)
		owner: 	a MenuMorph(744488960)
		submorphs: 	#()
		fullBounds: 	(44.0@556.0) corner: (180.0@574.0)
		color: 	Color black
		extension: 	a MorphExtension (165675008)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'Save'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	WorldState
		selector: 	#saveSession
		arguments: 	nil
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(78@567) mouseUp 17067694 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(134479872)'Save'
	Receiver's instance variables: 
		timeStamp: 	17067694
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(78@567)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(134479872)'Save'
	Arguments and temporary variables: 
		anEvent: 	[(78@567) mouseUp 17067694 nil]
	Receiver's instance variables: 
		bounds: 	(44.0@556.0) corner: (180.0@574.0)
		owner: 	a MenuMorph(744488960)
		submorphs: 	#()
		fullBounds: 	(44.0@556.0) corner: (180.0@574.0)
		color: 	Color black
		extension: 	a MorphExtension (165675008)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'Save'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	WorldState
		selector: 	#saveSession
		arguments: 	nil
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(78@567) mouseUp 17067694 nil]
		aMorph: 	a ToggleMenuItemMorph(134479872)'Save'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(134479872)'Save'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(78@567) mouseUp 17067694 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(134479872)'Save'


MouseButtonEvent>>sentTo:
	Receiver: [(78@567) mouseUp 17067694 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	17067694
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(78@567)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(78@567) mouseUp 17067694 nil]
		aMorph: 	a ToggleMenuItemMorph(134479872)'Save'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(134479872)'Save'


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(78@567) mouseUp 17067694 nil]
		aMorph: 	a ToggleMenuItemMorph(134479872)'Save'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(134479872)'Save'


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(134479872)'Save'
	Arguments and temporary variables: 
		anEvent: 	[(78@567) mouseUp 17067694 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(44.0@556.0) corner: (180.0@574.0)
		owner: 	a MenuMorph(744488960)
		submorphs: 	#()
		fullBounds: 	(44.0@556.0) corner: (180.0@574.0)
		color: 	Color black
		extension: 	a MorphExtension (165675008)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'Save'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	WorldState
		selector: 	#saveSession
		arguments: 	nil
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(78@567) mouseUp 17067694 nil]
		aMorph: 	a MenuMorph(744488960)
		localEvt: 	[(78@567) mouseUp 17067694 nil]
		index: 	14
		child: 	a ToggleMenuItemMorph(134479872)'Save'
		morphs: 	an Array(an AlignmentMorph(728236032) a ToggleMenuItemMorph(274202624)'...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(134479872)'Save'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(78@567) mouseUp 17067694 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(134479872)'Save'


MouseButtonEvent>>sentTo:
	Receiver: [(78@567) mouseUp 17067694 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	17067694
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(78@567)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4



--- The full stack ---
FileStream class(Object)>>doesNotUnderstand: #run:
ScriptStarter class>>executeRunFor:with:
ScriptStarter class>>startUp
ScriptStarter class(Behavior)>>startUp:
ScriptStarter class>>startUp:
[ class perform: startUpOrShutDown with: argument ] in [ :name | 
| class |
class := self at: name ifAbsent: [ nil ].
class
	ifNil: [ removals add: name ]
	ifNotNil: [ self logStartUpErrorDuring: [ class perform: startUpOrShutDown with: argument ] into: errors tryDebugger: false ] ] in SmalltalkImage>>send:toClassesNamedIn:with:
BlockClosure>>on:do:
SmalltalkImage>>logStartUpErrorDuring:into:tryDebugger:
[ :name | 
| class |
class := self at: name ifAbsent: [ nil ].
class
	ifNil: [ removals add: name ]
	ifNotNil: [ self logStartUpErrorDuring: [ class perform: startUpOrShutDown with: argument ] into: errors tryDebugger: false ] ] in SmalltalkImage>>send:toClassesNamedIn:with:
OrderedCollection>>do:
SmalltalkImage>>send:toClassesNamedIn:with:
SmalltalkImage>>processStartUpList:
[ 
startupErrors addAll: (self processStartUpList: isNewImage).
isNewImage
	ifTrue: [ self recordStartupStamp ] ] in SmalltalkImage>>startupImage:snapshotWorked:
BlockClosure>>ensure:
MorphicUIManager(UIManager)>>boot:during:
SmalltalkImage>>startupImage:snapshotWorked:
SmalltalkImage>>snapshot:andQuit:
[ Smalltalk snapshot: true andQuit: false ] in WorldState class>>saveSession
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
WorldState class>>saveSession
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got startup errors: 
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
    MessageNotUnderstood: FileStream class>>run:
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Command line handler failed
16 November 2015 3:32:14.180872 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:for:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
		aCommandLinehandler: 	a PharoCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ :exit | ^ self handleExit: exit ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>cull:
	Receiver: [ :exit | ^ self handleExit: exit ]
	Arguments and temporary variables: 
		anArg: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	73
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	Exit: Command line handler failed 1
		value: 	nil
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ ...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ ...etc...


Exit(Exception)>>signal
	Receiver: Exit: Command line handler failed 1
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Command line handler failed'
		tag: 	nil
		signaler: 	a PharoCommandLineHandler
		signalContext: 	Exit(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		status: 	1


Exit(Exception)>>signal:
	Receiver: Exit: Command line handler failed 1
	Arguments and temporary variables: 
		signalerText: 	'Command line handler failed'
	Receiver's instance variables: 
		messageText: 	'Command line handler failed'
		tag: 	nil
		signaler: 	a PharoCommandLineHandler
		signalContext: 	Exit(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		status: 	1


Exit class>>signalFailure:
	Receiver: Exit
	Arguments and temporary variables: 
		aMessage: 	'Command line handler failed'
	Receiver's instance variables: 
		superclass: 	Exception
		methodDict: 	a MethodDictionary(#defaultAction->Exit>>#defaultAction #isSuccess-...etc...
		format: 	144
		layout: 	a FixedLayout
		instanceVariables: 	#('status')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Exit
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Exceptions'
		traitComposition: 	{}
		localSelectors: 	nil


PharoCommandLineHandler(CommandLineHandler)>>exitFailure:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aMessage: 	'Command line handler failed'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(CommandLineHandler)>>exitFailure
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>error
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'FileStream'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GrowlMorph(401866752))(a GrowlMorph(...etc...
		lastStepTime: 	507
		lastStepMessage: 	nil
		lastCycleTime: 	539
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a CustomQuestionDialogWindow(7481...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GrowlMorph(401866752))(a GrowlMorph(...etc...
		lastStepTime: 	507
		lastStepMessage: 	nil
		lastCycleTime: 	539
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GrowlMorph(401866752))(a GrowlMorph(...etc...
		lastStepTime: 	507
		lastStepMessage: 	nil
		lastCycleTime: 	539
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a CustomQuestionDialogWindow(7481...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
| aWidget |
aWidget := aSystemWindow openAsIs.
self activeHand mouseFocus: aWidget.
[ aWidget world notNil ] whileTrue: [ aWidget outermostWorldMorph doOneCycle ] ] in WorldMorph(Morph)>>openModal:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aSystemWindow: 	a CustomQuestionDialogWindow(748158976)
		area: 	(0@0) corner: (976@634.0)
		mySysWin: 	a WorldMorph(511705088) [world]
		keyboardFocus: 	nil
		mouseFocus: 	nil
		aWidget: 	a CustomQuestionDialogWindow(748158976)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a CustomQuestionDialogWindow(7481...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


BlockClosure>>ensure:
	Receiver: [ 
| aWidget |
aWidget := aSystemWindow openAsIs.
self activeHand mouseFocus: aWidget.
[ a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
mySysWin modalUnlockFrom: aSystemWindow.
self activeHand newKeyboard...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph(Morph)>>openModal:
		startpc: 	200
		numArgs: 	0


WorldMorph(Morph)>>openModal:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aSystemWindow: 	a CustomQuestionDialogWindow(748158976)
		area: 	(0@0) corner: (976@634.0)
		mySysWin: 	a WorldMorph(511705088) [world]
		keyboardFocus: 	nil
		mouseFocus: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a CustomQuestionDialogWindow(7481...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>openModal:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aSystemWindow: 	a CustomQuestionDialogWindow(748158976)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a CustomQuestionDialogWindow(7481...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Pharo3Theme(UITheme)>>customQuestionIn:text:yesText:noText:cancelText:default:title:
	Receiver: a Pharo3Theme
	Arguments and temporary variables: 
		aThemedMorph: 	a WorldMorph(511705088) [world]
		labelText: 	'Got startup errors, proceed to open debuggers'
		yesText: 	'Debug'
		noText: 	'Cancel'
		cancelText: 	nil
		defaultOption: 	nil
		aString: 	'Question'
	Receiver's instance variables: 
		settings: 	a ThemeSettings
		forms: 	a Dictionary(#buttonBottomLeft->Form(12x12x32) #buttonBottomMiddle->Form...etc...
		soundTheme: 	nil
		focusIndicator: 	a PluggableButtonMorph(770441216)->a BorderedMorph(294125568)
		windowActiveDropShadowStyle: 	nil


MorphicUIManager>>confirm:trueChoice:falseChoice:cancelChoice:default:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		queryString: 	'Got startup errors, proceed to open debuggers'
		trueChoice: 	'Debug'
		falseChoice: 	'Cancel'
		cancelChoice: 	nil
		defaultOption: 	nil
	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


MorphicUIManager>>confirm:trueChoice:falseChoice:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		queryString: 	'Got startup errors, proceed to open debuggers'
		trueChoice: 	'Debug'
		falseChoice: 	'Cancel'
	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


SmalltalkImage>>handleStartupErrors:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		startupErrors: 	an OrderedCollection(MessageNotUnderstood: FileStream class>>run...etc...
		answer: 	nil
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection()
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


SmalltalkImage>>startupImage:snapshotWorked:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		isNewImage: 	true
		snapshotResult: 	true
		startupErrors: 	an OrderedCollection(MessageNotUnderstood: FileStream class>>run...etc...
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection()
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


SmalltalkImage>>snapshot:andQuit:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		snapshotResult: 	true
		isNewImage: 	true
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection()
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


[ Smalltalk snapshot: true andQuit: false ] in WorldState class>>saveSession
	Receiver: WorldState
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #addAlarm:w...etc...
		format: 	152
		layout: 	a FixedLayout
		instanceVariables: 	#('hands' 'viewBox' 'canvas' 'damageRecorder' 'stepList' 'la...etc...
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->true #DebugShowDamage->false #Deferr...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>ensure:
	Receiver: [ Smalltalk snapshot: true andQuit: false ]
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldState class>>saveSession
		startpc: 	39
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r11000000000000000000
...etc...
	Arguments and temporary variables: 
		aBlock: 	[ Smalltalk snapshot: true andQuit: false ]
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


WorldState class>>saveSession
	Receiver: WorldState
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #addAlarm:w...etc...
		format: 	152
		layout: 	a FixedLayout
		instanceVariables: 	#('hands' 'viewBox' 'canvas' 'damageRecorder' 'stepList' 'la...etc...
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->true #DebugShowDamage->false #Deferr...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil


[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(134479872)'Save'
	Arguments and temporary variables: 
		evt: 	[(78@567) mouseUp 17067694 nil]
		w: 	a WorldMorph(511705088) [world]
		selArgCount: 	0
	Receiver's instance variables: 
		bounds: 	(44.0@556.0) corner: (180.0@574.0)
		owner: 	a MenuMorph(744488960)
		submorphs: 	#()
		fullBounds: 	(44.0@556.0) corner: (180.0@574.0)
		color: 	Color black
		extension: 	a MorphExtension (165675008)
		font: 	a LogicalFont
 familyName: Source Sans Pro
 emphasis: nil
 pointSize: 10
...etc...
		emphasis: 	0
		contents: 	'Save'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	WorldState
		selector: 	#saveSession
		arguments: 	nil
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	nil



--- The full stack ---
PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:for:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:
[ :exit | ^ self handleExit: exit ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
Exit(Exception)>>signal
Exit(Exception)>>signal:
Exit class>>signalFailure:
PharoCommandLineHandler(CommandLineHandler)>>exitFailure:
PharoCommandLineHandler(CommandLineHandler)>>exitFailure
PharoCommandLineHandler(BasicCommandLineHandler)>>error
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
| aWidget |
aWidget := aSystemWindow openAsIs.
self activeHand mouseFocus: aWidget.
[ aWidget world notNil ] whileTrue: [ aWidget outermostWorldMorph doOneCycle ] ] in WorldMorph(Morph)>>openModal:
BlockClosure>>ensure:
WorldMorph(Morph)>>openModal:
WorldMorph(PasteUpMorph)>>openModal:
Pharo3Theme(UITheme)>>customQuestionIn:text:yesText:noText:cancelText:default:title:
MorphicUIManager>>confirm:trueChoice:falseChoice:cancelChoice:default:
MorphicUIManager>>confirm:trueChoice:falseChoice:
SmalltalkImage>>handleStartupErrors:
SmalltalkImage>>startupImage:snapshotWorked:
SmalltalkImage>>snapshot:andQuit:
[ Smalltalk snapshot: true andQuit: false ] in WorldState class>>saveSession
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
WorldState class>>saveSession
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "nextPutAll:" is nil
16 November 2015 3:32:39.199321 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

UndefinedObject(Object)>>doesNotUnderstand: #nextPutAll:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	nextPutAll: 'aaa'
		exception: 	MessageNotUnderstood: receiver of "nextPutAll:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	FileStream forceNewFileNamed: 'c:/test2.txt'.
	^ stream
		nextPutAll...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler(AbstractCompiler)>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'FileStream forceNewFileNamed: ''c:/test2.txt''. stream nextPutAl...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	FileStream forceNewFileNamed: 'c:/test2.txt'.
	^ stream
		nextPutAll...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkImage>>evaluate:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		aString: 	'FileStream forceNewFileNamed: ''c:/test2.txt''. stream nextPutAll:''a...etc...
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection()
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aStream: 	'FileStream forceNewFileNamed: ''c:/test2.txt''. stream nextPutAll:''a...etc...
		exceptionClassToUse: 	OCSemanticWarning
		result: 	nil
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


BlockClosure>>on:do:
	Receiver: [ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdou...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :error | self handleError: error ]
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		startpc: 	110
		numArgs: 	0


EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		result: 	nil
		aStream: 	'FileStream forceNewFileNamed: ''c:/test2.txt''. stream nextPutAll:''a...etc...
		exceptionClassToUse: 	OCSemanticWarning
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>evaluateArguments
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		argumentString: 	'FileStream forceNewFileNamed: ''c:/test2.txt''. stream nextPut...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>activate
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	STCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->EvaluateCommandLineHandler>>#activate...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#EvaluateCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImport-CommandLineHandlers'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(EvaluateCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	a FormCanvas on: DisplayScreen(976x662x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GrowlMorph(347340800))(a GrowlMorph(...etc...
		lastStepTime: 	331
		lastStepMessage: 	nil
		lastCycleTime: 	330
		alarms: 	a Heap()
		lastAlarmTime: 	331
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GrowlMorph(347340800) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	a FormCanvas on: DisplayScreen(976x662x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GrowlMorph(347340800))(a GrowlMorph(...etc...
		lastStepTime: 	331
		lastStepMessage: 	nil
		lastCycleTime: 	330
		alarms: 	a Heap()
		lastAlarmTime: 	331
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	a FormCanvas on: DisplayScreen(976x662x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GrowlMorph(347340800))(a GrowlMorph(...etc...
		lastStepTime: 	331
		lastStepMessage: 	nil
		lastCycleTime: 	330
		alarms: 	a Heap()
		lastAlarmTime: 	331
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GrowlMorph(347340800) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #nextPutAll:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
OpalCompiler(AbstractCompiler)>>evaluate:
SmalltalkImage>>evaluate:
[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
BlockClosure>>on:do:
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Command line handler failed
16 November 2015 3:39:18.583164 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:for:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
		aCommandLinehandler: 	a PharoCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ :exit | ^ self handleExit: exit ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>cull:
	Receiver: [ :exit | ^ self handleExit: exit ]
	Arguments and temporary variables: 
		anArg: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	73
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	Exit: Command line handler failed 1
		value: 	nil
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ ...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ ...etc...


Exit(Exception)>>signal
	Receiver: Exit: Command line handler failed 1
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Command line handler failed'
		tag: 	nil
		signaler: 	a PharoCommandLineHandler
		signalContext: 	Exit(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		status: 	1


Exit(Exception)>>signal:
	Receiver: Exit: Command line handler failed 1
	Arguments and temporary variables: 
		signalerText: 	'Command line handler failed'
	Receiver's instance variables: 
		messageText: 	'Command line handler failed'
		tag: 	nil
		signaler: 	a PharoCommandLineHandler
		signalContext: 	Exit(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		status: 	1


Exit class>>signalFailure:
	Receiver: Exit
	Arguments and temporary variables: 
		aMessage: 	'Command line handler failed'
	Receiver's instance variables: 
		superclass: 	Exception
		methodDict: 	a MethodDictionary(#defaultAction->Exit>>#defaultAction #isSuccess-...etc...
		format: 	144
		layout: 	a FixedLayout
		instanceVariables: 	#('status')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Exit
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Exceptions'
		traitComposition: 	{}
		localSelectors: 	nil


PharoCommandLineHandler(CommandLineHandler)>>exitFailure:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aMessage: 	'Command line handler failed'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(CommandLineHandler)>>exitFailure
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>error
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'stream'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 2 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GrowlMorph(374341632))(a GrowlMorph(...etc...
		lastStepTime: 	223
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GrowlMorph(374341632) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GrowlMorph(374341632))(a GrowlMorph(...etc...
		lastStepTime: 	223
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GrowlMorph(374341632))(a GrowlMorph(...etc...
		lastStepTime: 	223
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GrowlMorph(374341632) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:for:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:
[ :exit | ^ self handleExit: exit ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
Exit(Exception)>>signal
Exit(Exception)>>signal:
Exit class>>signalFailure:
PharoCommandLineHandler(CommandLineHandler)>>exitFailure:
PharoCommandLineHandler(CommandLineHandler)>>exitFailure
PharoCommandLineHandler(BasicCommandLineHandler)>>error
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Command line handler failed
16 November 2015 3:41:20.930163 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:for:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
		aCommandLinehandler: 	a PharoCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ :exit | ^ self handleExit: exit ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		exit: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>cull:
	Receiver: [ :exit | ^ self handleExit: exit ]
	Arguments and temporary variables: 
		anArg: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	73
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	Exit: Command line handler failed 1
		value: 	nil
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ ...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	Exit: Command line handler failed 1
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ ...etc...


Exit(Exception)>>signal
	Receiver: Exit: Command line handler failed 1
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Command line handler failed'
		tag: 	nil
		signaler: 	a PharoCommandLineHandler
		signalContext: 	Exit(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		status: 	1


Exit(Exception)>>signal:
	Receiver: Exit: Command line handler failed 1
	Arguments and temporary variables: 
		signalerText: 	'Command line handler failed'
	Receiver's instance variables: 
		messageText: 	'Command line handler failed'
		tag: 	nil
		signaler: 	a PharoCommandLineHandler
		signalContext: 	Exit(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		status: 	1


Exit class>>signalFailure:
	Receiver: Exit
	Arguments and temporary variables: 
		aMessage: 	'Command line handler failed'
	Receiver's instance variables: 
		superclass: 	Exception
		methodDict: 	a MethodDictionary(#defaultAction->Exit>>#defaultAction #isSuccess-...etc...
		format: 	144
		layout: 	a FixedLayout
		instanceVariables: 	#('status')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Exit
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Exceptions'
		traitComposition: 	{}
		localSelectors: 	nil


PharoCommandLineHandler(CommandLineHandler)>>exitFailure:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aMessage: 	'Command line handler failed'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(CommandLineHandler)>>exitFailure
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>error
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'stream'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 2 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GrowlMorph(408682496))(a GrowlMorph(...etc...
		lastStepTime: 	150
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GrowlMorph(408682496) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GrowlMorph(408682496))(a GrowlMorph(...etc...
		lastStepTime: 	150
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GrowlMorph(408682496))(a GrowlMorph(...etc...
		lastStepTime: 	150
		lastStepMessage: 	nil
		lastCycleTime: 	1091986
		alarms: 	a Heap()
		lastAlarmTime: 	1091966
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GrowlMorph(408682496) a SpecWin...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:for:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleExit:
[ :exit | ^ self handleExit: exit ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
Exit(Exception)>>signal
Exit(Exception)>>signal:
Exit class>>signalFailure:
PharoCommandLineHandler(CommandLineHandler)>>exitFailure:
PharoCommandLineHandler(CommandLineHandler)>>exitFailure
PharoCommandLineHandler(BasicCommandLineHandler)>>error
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Abort: Please close this to abort file opening
16 November 2015 3:47:14.163237 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

MultiByteFileStream class(StandardFileStream class)>>fileExistsUserHandling:
	Receiver: MultiByteFileStream
	Arguments and temporary variables: 
		fullFileName: 	'C:\Users\Vincent\Downloads\ClockSystem (2)\test.gml'
		file: 	File @ C:\Users\Vincent\Downloads\ClockSystem (2)\test.gml
		localName: 	'test.gml'
		choice: 	0
		newName: 	nil
		newFullFileName: 	nil
	Receiver's instance variables: 
		superclass: 	StandardFileStream
		methodDict: 	a MethodDictionary(#accepts:->MultiByteFileStream>>#accepts: #ascii...etc...
		format: 	152
		layout: 	a FixedLayout
		instanceVariables: 	#('converter' 'lineEndConvention' 'wantsLineEndConversion')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MultiByteFileStream
		classPool: 	a Dictionary(#Cr->Character cr #CrLf->'

' #Lf->Character lf #LineEn...etc...
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


MorphicUIManager>>fileExistsDefaultAction:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		anException: 	FileExistsException: 'C:\Users\Vincent\Downloads\ClockSystem (2)\t...etc...
	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


FileExistsException>>defaultAction
	Receiver: FileExistsException: 'C:\Users\Vincent\Downloads\ClockSystem (2)\test.gml'
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	MultiByteFileStream
		signalContext: 	FileExistsException(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		fileName: 	'C:\Users\Vincent\Downloads\ClockSystem (2)\test.gml'
		fileClass: 	MultiByteFileStream


UndefinedObject>>handleSignal:
	Receiver: nil
	Arguments and temporary variables: 
		exception: 	FileExistsException: 'C:\Users\Vincent\Downloads\ClockSystem (2)\tes...etc...
	Receiver's instance variables: 
nil

FileExistsException(Exception)>>pass
	Receiver: FileExistsException: 'C:\Users\Vincent\Downloads\ClockSystem (2)\test.gml'
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	MultiByteFileStream
		signalContext: 	FileExistsException(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		fileName: 	'C:\Users\Vincent\Downloads\ClockSystem (2)\test.gml'
		fileClass: 	MultiByteFileStream


[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
ActiveHand := priorHand.
ex pass ] in WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(641@208) mouseOver red nil nil]
		ex: 	FileExistsException: 'C:\Users\Vincent\Downloads\ClockSystem (2)\test.gml'
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(19660800) a LabelMor...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


BlockClosure>>cull:
	Receiver: [ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
ActiveHand := priorHand.
ex...etc...
	Arguments and temporary variables: 
		anArg: 	FileExistsException: 'C:\Users\Vincent\Downloads\ClockSystem (2)\test.gm...etc...
	Receiver's instance variables: 
		outerContext: 	WorldMorph(PasteUpMorph)>>becomeActiveDuring:
		startpc: 	71
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileExistsException: 'C:\Users\Vincent\Downloads\ClockSystem (2)\tes...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	WorldMorph(PasteUpMorph)>>becomeActiveDuring:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileExistsException: 'C:\Users\Vincent\Downloads\ClockSystem (2)\tes...etc...
	Receiver's instance variables: 
		sender: 	WorldMorph(PasteUpMorph)>>becomeActiveDuring:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ...etc...


FileExistsException(Exception)>>signal
	Receiver: FileExistsException: 'C:\Users\Vincent\Downloads\ClockSystem (2)\test.gml'
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	MultiByteFileStream
		signalContext: 	FileExistsException(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		fileName: 	'C:\Users\Vincent\Downloads\ClockSystem (2)\test.gml'
		fileClass: 	MultiByteFileStream


MultiByteFileStream class(StandardFileStream class)>>newFileNamed:
	Receiver: MultiByteFileStream
	Arguments and temporary variables: 
		fileName: 	'C:\Users\Vincent\Downloads\ClockSystem (2)\test.gml'
		fullName: 	'C:\Users\Vincent\Downloads\ClockSystem (2)\test.gml'
	Receiver's instance variables: 
		superclass: 	StandardFileStream
		methodDict: 	a MethodDictionary(#accepts:->MultiByteFileStream>>#accepts: #ascii...etc...
		format: 	152
		layout: 	a FixedLayout
		instanceVariables: 	#('converter' 'lineEndConvention' 'wantsLineEndConversion')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MultiByteFileStream
		classPool: 	a Dictionary(#Cr->Character cr #CrLf->'

' #Lf->Character lf #LineEn...etc...
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>newFileNamed:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	File @ C:\Users\Vincent\Downloads\ClockSystem (2)\test.gml
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ self newFileNamed: fileName ] in FileStream class>>newFileNamed:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	File @ C:\Users\Vincent\Downloads\ClockSystem (2)\test.gml
		aBlock: 	[ :stream | TraConfigurationGraph2GML gml: explorationResult in: stream...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>detectFile:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		aBlock: 	[ self newFileNamed: fileName ]
		anotherBlock: 	[ :stream | TraConfigurationGraph2GML gml: explorationResult in: ...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>newFileNamed:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	File @ C:\Users\Vincent\Downloads\ClockSystem (2)\test.gml
		aBlock: 	[ :stream | TraConfigurationGraph2GML gml: explorationResult in: stream...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


ClockSystemEditorModel>>saveGML
	Receiver: a ClockSystemEditorModel
	Arguments and temporary variables: 
		newFile: 	File @ C:\Users\Vincent\Downloads\ClockSystem (2)\test.gml
	Receiver's instance variables: 
		file: 	File @ C:\Users\Vincent\Downloads\ClockSystem (2)\test.ccsl
		explorationResult: 	a ClockConfigurationGraph
		system: 	ClockSystem myApplication_withMoC-xSigpmlMocc
executeB1.
executeB2.
lib...etc...
		fiacreGraph: 	nil


[ self model saveGML ] in [ :item | 
item
	name: nil;
	description: 'Save GML';
	icon: ClockSystemIcons graph;
	action: [ self model saveGML ].
menuItems add: #saveGML -> item ] in ClockSystemEditor>>itemSaveGML:
	Receiver: a ClockSystemEditor
	Arguments and temporary variables: 
		group: 	a MenuGroupModel
		item: 	a MenuItemModel
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		focusOrder: 	an OrderedCollection(a TextModel)
		owner: 	a ClockSystemBrowser
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		menu: 	a MenuModel
		code: 	a TextModel
		model: 	a ClockSystemEditorModel
		modelHandler: 	nil
		menuItems: 	a Dictionary(#explore->a MenuItemModel #saveFiacre->a MenuItemModel ...etc...


BlockClosure>>cull:
	Receiver: [ self model saveGML ]
	Arguments and temporary variables: 
		anArg: 	a ToolDockingBarMorph(105119744)
	Receiver's instance variables: 
		outerContext: 	[ :item | 
item
	name: nil;
	description: 'Save GML';
	icon: Cloc...etc...
		startpc: 	84
		numArgs: 	0


MenuItemModel>>performMenuActionWith:
	Receiver: a MenuItemModel
	Arguments and temporary variables: 
		aMenuItem: 	a ToolDockingBarMorph(105119744)
		en: 	true
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(115867648))
		focusOrder: 	nil
		owner: 	nil
		window: 	a NewValueHolder[ nil ]
		spec: 	nil
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		announcer: 	a NewValueHolder[ an Announcer ]
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		helpHolder: 	a NewValueHolder[ nil ]
		borderWidth: 	a NewValueHolder[ 0 ]
		borderColor: 	a NewValueHolder[ Color transparent ]
		enabledHolder: 	a NewValueHolder[ true ]
		dragEnabled: 	a NewValueHolder[ false ]
		dropEnabled: 	a NewValueHolder[ false ]
		dragTransformationBlock: 	a NewValueHolder[ [ :item :source | item ] ]
		wantDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source | self dropEnabl...etc...
		acceptDropBlock: 	a NewValueHolder[ [ :draggedItem :event :source |  ] ]
		transferBlock: 	a NewValueHolder[ [ :passenger :source | super transferFor: pass...etc...
		color: 	a NewValueHolder[ Color white ]
		action: 	a NewValueHolder[ [ self model saveGML ] ]
		name: 	a CollectionValueHolder[ nil ]
		shortcut: 	a NewValueHolder[ nil ]
		subMenu: 	a NewValueHolder[ nil ]
		icon: 	a NewValueHolder[ Form(31x14x32) ]
		description: 	a NewValueHolder[ 'Save GML' ]
		state: 	a NewValueHolder[ nil ]
		enabled: 	a NewValueHolder[ true ]
		autoRefresh: 	a NewValueHolder[ true ]


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(115867648)
	Arguments and temporary variables: 
		event: 	[(641@208) mouseUp 22753915 nil]
	Receiver's instance variables: 
		bounds: 	(625.0@197.0) corner: (664.0@221.0)
		owner: 	a ToolDockingBarMorph(105119744)
		submorphs: 	an Array(an AlignmentMorph(300679168))
		fullBounds: 	(625@197) corner: (664@221)
		color: 	(Color r: 0.794 g: 0.868 b: 0.9400000000000001 alpha: 1.0)
		extension: 	a MorphExtension (207355904) [balloonText]  [other:  (lastState -> t...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MenuItemModel
		label: 	an IconicListItem(808189952)
		getStateSelector: 	#enabled
		actionSelector: 	#performMenuActionWith:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	an Array(a ToolDockingBarMorph(105119744))
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	an IconicListItem(808189952)


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(115867648)
	Arguments and temporary variables: 
		evt: 	[(641@208) mouseUp 22753915 nil]
		all: 	an Array(a PluggableButtonMorph(421527552) a PluggableButtonMorph(87189094...etc...
		m: 	a PluggableButtonMorph(115867648)
	Receiver's instance variables: 
		bounds: 	(625.0@197.0) corner: (664.0@221.0)
		owner: 	a ToolDockingBarMorph(105119744)
		submorphs: 	an Array(an AlignmentMorph(300679168))
		fullBounds: 	(625@197) corner: (664@221)
		color: 	(Color r: 0.794 g: 0.868 b: 0.9400000000000001 alpha: 1.0)
		extension: 	a MorphExtension (207355904) [balloonText]  [other:  (lastState -> t...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MenuItemModel
		label: 	an IconicListItem(808189952)
		getStateSelector: 	#enabled
		actionSelector: 	#performMenuActionWith:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	an Array(a ToolDockingBarMorph(105119744))
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	an IconicListItem(808189952)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(421527552) a PluggableButtonMorph(871890944) a PluggableBu...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			i...etc...
		index: 	8
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(421527552) a PluggableButtonMorph(871890944) a PluggableBu...etc...

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(115867648)
	Arguments and temporary variables: 
		evt: 	[(641@208) mouseUp 22753915 nil]
		all: 	an Array(a PluggableButtonMorph(421527552) a PluggableButtonMorph(87189094...etc...
	Receiver's instance variables: 
		bounds: 	(625.0@197.0) corner: (664.0@221.0)
		owner: 	a ToolDockingBarMorph(105119744)
		submorphs: 	an Array(an AlignmentMorph(300679168))
		fullBounds: 	(625@197) corner: (664@221)
		color: 	(Color r: 0.794 g: 0.868 b: 0.9400000000000001 alpha: 1.0)
		extension: 	a MorphExtension (207355904) [balloonText]  [other:  (lastState -> t...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MenuItemModel
		label: 	an IconicListItem(808189952)
		getStateSelector: 	#enabled
		actionSelector: 	#performMenuActionWith:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	an Array(a ToolDockingBarMorph(105119744))
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	an IconicListItem(808189952)


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(115867648)
	Arguments and temporary variables: 
		anEvent: 	[(641@208) mouseUp 22753915 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(625.0@197.0) corner: (664.0@221.0)
		owner: 	a ToolDockingBarMorph(105119744)
		submorphs: 	an Array(an AlignmentMorph(300679168))
		fullBounds: 	(625@197) corner: (664@221)
		color: 	(Color r: 0.794 g: 0.868 b: 0.9400000000000001 alpha: 1.0)
		extension: 	a MorphExtension (207355904) [balloonText]  [other:  (lastState -> t...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MenuItemModel
		label: 	an IconicListItem(808189952)
		getStateSelector: 	#enabled
		actionSelector: 	#performMenuActionWith:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	an Array(a ToolDockingBarMorph(105119744))
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	an IconicListItem(808189952)


MouseButtonEvent>>sentTo:
	Receiver: [(641@208) mouseUp 22753915 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(115867648)
	Receiver's instance variables: 
		timeStamp: 	22753915
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(641@208)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(115867648)
	Arguments and temporary variables: 
		anEvent: 	[(641@208) mouseUp 22753915 nil]
	Receiver's instance variables: 
		bounds: 	(625.0@197.0) corner: (664.0@221.0)
		owner: 	a ToolDockingBarMorph(105119744)
		submorphs: 	an Array(an AlignmentMorph(300679168))
		fullBounds: 	(625@197) corner: (664@221)
		color: 	(Color r: 0.794 g: 0.868 b: 0.9400000000000001 alpha: 1.0)
		extension: 	a MorphExtension (207355904) [balloonText]  [other:  (lastState -> t...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MenuItemModel
		label: 	an IconicListItem(808189952)
		getStateSelector: 	#enabled
		actionSelector: 	#performMenuActionWith:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	an Array(a ToolDockingBarMorph(105119744))
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	an IconicListItem(808189952)


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(115867648)
	Arguments and temporary variables: 
		anEvent: 	[(641@208) mouseUp 22753915 nil]
	Receiver's instance variables: 
		bounds: 	(625.0@197.0) corner: (664.0@221.0)
		owner: 	a ToolDockingBarMorph(105119744)
		submorphs: 	an Array(an AlignmentMorph(300679168))
		fullBounds: 	(625@197) corner: (664@221)
		color: 	(Color r: 0.794 g: 0.868 b: 0.9400000000000001 alpha: 1.0)
		extension: 	a MorphExtension (207355904) [balloonText]  [other:  (lastState -> t...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MenuItemModel
		label: 	an IconicListItem(808189952)
		getStateSelector: 	#enabled
		actionSelector: 	#performMenuActionWith:
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	an Array(a ToolDockingBarMorph(105119744))
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		lastColor: 	nil
		labelMorph: 	an IconicListItem(808189952)


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(641@208) mouseUp 22753915 nil]
		focusHolder: 	a PluggableButtonMorph(115867648)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(782@242) corner: (798@258)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(782@242) corner: (798@258)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(122159104)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(790@251) mouseOver nil nil]
		targetOffset: 	(28.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 22756193 794 253 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(641@208) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@662)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(19660800) a LabelMor...etc...
		fullBounds: 	(0@0) corner: (976@662)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(641@208) mouseUp 22753915 nil]
		focusHolder: 	a PluggableButtonMorph(115867648)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(773@238) corner: (789@254)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(773@238) corner: (789@254)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(122159104)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(781@247) mouseOver nil nil]
		targetOffset: 	(28.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 22756224 786 250 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(641@208) mouseUp 22753915 nil]
		focusHolder: 	a PluggableButtonMorph(115867648)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(773@238) corner: (789@254)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(773@238) corner: (789@254)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(122159104)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(781@247) mouseOver nil nil]
		targetOffset: 	(28.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 22756271 775 246 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(641@208) mouseUp 22753915 nil]
	Receiver's instance variables: 
		bounds: 	(767@237) corner: (783@253)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(767@237) corner: (783@253)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(122159104)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(775@246) mouseOver nil nil]
		targetOffset: 	(28.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 22756271 775 246 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(641@208) mouseUp 22753915 nil]
		evt: 	[(641@208) mouseUp 22753915 nil]
	Receiver's instance variables: 
		bounds: 	(763@235) corner: (779@251)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(763@235) corner: (779@251)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(122159104)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(771@244) mouseOver nil nil]
		targetOffset: 	(28.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 22756287 771 244 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(641@208) mouseUp 22753915 nil]
		evtBuf: 	#(1 22753915 641 208 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(763@235) corner: (779@251)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(763@235) corner: (779@251)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(122159104)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(771@244) mouseOver nil nil]
		targetOffset: 	(28.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 22756287 771 244 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	a FormCanvas on: DisplayScreen(976x662x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#onBlinkCursor -> a TextMorphForEditView(122159104...etc...
		lastStepTime: 	1209281
		lastStepMessage: 	nil
		lastCycleTime: 	1209281
		alarms: 	a Heap()
		lastAlarmTime: 	1209281
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	a FormCanvas on: DisplayScreen(976x662x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#onBlinkCursor -> a TextMorphForEditView(122159104...etc...
		lastStepTime: 	1209281
		lastStepMessage: 	nil
		lastCycleTime: 	1209281
		alarms: 	a Heap()
		lastAlarmTime: 	1209281
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (976@662)
		canvas: 	a FormCanvas on: DisplayScreen(976x662x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#onBlinkCursor -> a TextMorphForEditView(122159104...etc...
		lastStepTime: 	1209281
		lastStepMessage: 	nil
		lastCycleTime: 	1209281
		alarms: 	a Heap()
		lastAlarmTime: 	1209281
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 



--- The full stack ---
MultiByteFileStream class(StandardFileStream class)>>fileExistsUserHandling:
MorphicUIManager>>fileExistsDefaultAction:
FileExistsException>>defaultAction
UndefinedObject>>handleSignal:
FileExistsException(Exception)>>pass
[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
ActiveHand := priorHand.
ex pass ] in WorldMorph(PasteUpMorph)>>becomeActiveDuring:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
FileExistsException(Exception)>>signal
MultiByteFileStream class(StandardFileStream class)>>newFileNamed:
FileStream class>>newFileNamed:
[ self newFileNamed: fileName ] in FileStream class>>newFileNamed:do:
FileStream class>>detectFile:do:
FileStream class>>newFileNamed:do:
ClockSystemEditorModel>>saveGML
[ self model saveGML ] in [ :item | 
item
	name: nil;
	description: 'Save GML';
	icon: ClockSystemIcons graph;
	action: [ self model saveGML ].
menuItems add: #saveGML -> item ] in ClockSystemEditor>>itemSaveGML:
BlockClosure>>cull:
MenuItemModel>>performMenuActionWith:
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ 
		m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: StandardFileStream class>>nextPutAll:
16 November 2015 4:08:22.15058 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

StandardFileStream class(Object)>>doesNotUnderstand: #nextPutAll:
	Receiver: StandardFileStream
	Arguments and temporary variables: 
		aMessage: 	nextPutAll: 'system myApplication_withMoC-xSigpmlMocc'
		exception: 	MessageNotUnderstood: StandardFileStream class>>nextPutAll:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	FileStream
		methodDict: 	a MethodDictionary(#actAsExecutor->StandardFileStream>>#actAsExecut...etc...
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#('name' 'fileID' 'buffer1')
		organization: 	a ClassOrganization
		subclasses: 	{MultiByteFileStream. AttachableFileStream}
		name: 	#StandardFileStream
		classPool: 	a Dictionary(#Registry->a WeakRegistry(<this WeakRegistry is locked>...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ :stream | 
stream
	nextPutAll: 'system ' , sysName;
	cr;
	nextPutAll: 'ERROR' ] in [ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr;
			nextPutAll: 'ERROR' ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	ClockSystem myApplication_withMoC-xSigpmlMocc
executeB1.
executeB...etc...
		result: 	a ClockConfigurationGraph
		resultsPath: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'
		fiacreGraph: 	nil
		sysName: 	'myApplication_withMoC-xSigpmlMocc'
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	1
		mtxFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMoC...etc...
		ltsFile: 	nil
		resultFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_with...etc...
		stream: 	StandardFileStream
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


[ anotherBlock value: file ] in FileStream class>>detectFile:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		aBlock: 	[ self forceNewFileNamed: fileName ]
		anotherBlock: 	[ :stream | 
stream
	nextPutAll: 'system ' , sysName;
	cr;
	nextP...etc...
		file: 	StandardFileStream
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>ensure:
	Receiver: [ anotherBlock value: file ]
	Arguments and temporary variables: 
		aBlock: 	[ file close ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	FileStream class>>detectFile:do:
		startpc: 	41
		numArgs: 	0


FileStream class>>detectFile:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		aBlock: 	[ self forceNewFileNamed: fileName ]
		anotherBlock: 	[ :stream | 
stream
	nextPutAll: 'system ' , sysName;
	cr;
	nextP...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>forceNewFileNamed:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMo...etc...
		aBlock: 	[ :stream | 
stream
	nextPutAll: 'system ' , sysName;
	cr;
	nextPutAll:...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr;
			nextPutAll: 'ERROR' ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	ClockSystem myApplication_withMoC-xSigpmlMocc
executeB1.
executeB...etc...
		result: 	a ClockConfigurationGraph
		resultsPath: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'
		fiacreGraph: 	nil
		sysName: 	'myApplication_withMoC-xSigpmlMocc'
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	1
		mtxFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMoC...etc...
		ltsFile: 	nil
		resultFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_with...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: r...etc...
	Arguments and temporary variables: 
		anArg: 	FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp-bri...etc...
	Receiver's instance variables: 
		outerContext: 	ClockSystem4GeMoC class>>explore:resultIn:
		startpc: 	495
		numArgs: 	0


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	ClockSystem4GeMoC class>>explore:resultIn:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProdu...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp...etc...
	Receiver's instance variables: 
		sender: 	ClockSystem4GeMoC class>>explore:resultIn:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProdu...etc...


FileDoesNotExistException(Exception)>>signal
	Receiver: FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp-bridge\myApplication_...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	MultiByteFileStream
		signalContext: 	FileDoesNotExistException(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		fileName: 	'\Users\ciprian\Playfield\GeMOC\gemoc-obp-bridge\myApplication_withMo...etc...
		readOnly: 	nil


MultiByteFileStream class(StandardFileStream class)>>forceNewFileNamed:
	Receiver: MultiByteFileStream
	Arguments and temporary variables: 
		fileName: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMo...etc...
		dir: 	nil
		fullName: 	'\Users\ciprian\Playfield\GeMOC\gemoc-obp-bridge\myApplication_withMo...etc...
		f: 	nil
	Receiver's instance variables: 
		superclass: 	StandardFileStream
		methodDict: 	a MethodDictionary(#accepts:->MultiByteFileStream>>#accepts: #ascii...etc...
		format: 	152
		layout: 	a FixedLayout
		instanceVariables: 	#('converter' 'lineEndConvention' 'wantsLineEndConversion')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MultiByteFileStream
		classPool: 	a Dictionary(#Cr->Character cr #CrLf->'

' #Lf->Character lf #LineEn...etc...
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>forceNewFileNamed:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMo...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ self forceNewFileNamed: fileName ] in FileStream class>>forceNewFileNamed:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMo...etc...
		aBlock: 	[ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ]...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>detectFile:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		aBlock: 	[ self forceNewFileNamed: fileName ]
		anotherBlock: 	[ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: st...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>forceNewFileNamed:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMo...etc...
		aBlock: 	[ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ]...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	ClockSystem myApplication_withMoC-xSigpmlMocc
executeB1.
executeB...etc...
		result: 	a ClockConfigurationGraph
		resultsPath: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'
		fiacreGraph: 	nil
		sysName: 	'myApplication_withMoC-xSigpmlMocc'
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	1
		mtxFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMoC...etc...
		ltsFile: 	nil
		resultFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_with...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>on:do:
	Receiver: [ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration explore...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileSt...etc...
	Receiver's instance variables: 
		outerContext: 	ClockSystem4GeMoC class>>explore:resultIn:
		startpc: 	186
		numArgs: 	0


ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		result: 	a ClockConfigurationGraph
		resultsPath: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'
		fiacreGraph: 	nil
		sysName: 	'myApplication_withMoC-xSigpmlMocc'
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	1
		mtxFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMoC...etc...
		ltsFile: 	nil
		resultFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_with...etc...
		aClockSystem: 	ClockSystem myApplication_withMoC-xSigpmlMocc
executeB1.
executeB...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	stream := FileStream
		readOnlyFileNamed:
			'C:\\g\\Gemoc\\trunk\\w...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler(AbstractCompiler)>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'stream := FileStream readOnlyFileNamed: ''C:\\g\\Gemoc\\trunk\\w...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	stream := FileStream
		readOnlyFileNamed:
			'C:\\g\\Gemoc\\trunk\\w...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkImage>>evaluate:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		aString: 	'stream := FileStream readOnlyFileNamed: ''C:\\g\\Gemoc\\trunk\\worksp...etc...
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection()
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aStream: 	'stream := FileStream readOnlyFileNamed: ''C:\\g\\Gemoc\\trunk\\worksp...etc...
		exceptionClassToUse: 	OCSemanticWarning
		result: 	nil
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


BlockClosure>>on:do:
	Receiver: [ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdou...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :error | self handleError: error ]
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		startpc: 	110
		numArgs: 	0


EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		result: 	nil
		aStream: 	'stream := FileStream readOnlyFileNamed: ''C:\\g\\Gemoc\\trunk\\worksp...etc...
		exceptionClassToUse: 	OCSemanticWarning
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>evaluateArguments
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		argumentString: 	'stream := FileStream readOnlyFileNamed: ''C:\\g\\Gemoc\\trunk\...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>activate
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	STCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->EvaluateCommandLineHandler>>#activate...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#EvaluateCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImport-CommandLineHandlers'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(EvaluateCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil



--- The full stack ---
StandardFileStream class(Object)>>doesNotUnderstand: #nextPutAll:
[ :stream | 
stream
	nextPutAll: 'system ' , sysName;
	cr;
	nextPutAll: 'ERROR' ] in [ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr;
			nextPutAll: 'ERROR' ] ] in ClockSystem4GeMoC class>>explore:resultIn:
[ anotherBlock value: file ] in FileStream class>>detectFile:do:
BlockClosure>>ensure:
FileStream class>>detectFile:do:
FileStream class>>forceNewFileNamed:do:
[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr;
			nextPutAll: 'ERROR' ] ] in ClockSystem4GeMoC class>>explore:resultIn:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
FileDoesNotExistException(Exception)>>signal
MultiByteFileStream class(StandardFileStream class)>>forceNewFileNamed:
FileStream class>>forceNewFileNamed:
[ self forceNewFileNamed: fileName ] in FileStream class>>forceNewFileNamed:do:
FileStream class>>detectFile:do:
FileStream class>>forceNewFileNamed:do:
[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
BlockClosure>>on:do:
ClockSystem4GeMoC class>>explore:resultIn:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
OpalCompiler(AbstractCompiler)>>evaluate:
SmalltalkImage>>evaluate:
[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
BlockClosure>>on:do:
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Unwind error during termination
16 November 2015 4:09:12.97858 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

StandardFileStream class(Object)>>doesNotUnderstand: #close
	Receiver: StandardFileStream
	Arguments and temporary variables: 
		aMessage: 	close
		exception: 	MessageNotUnderstood: StandardFileStream class>>close
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	FileStream
		methodDict: 	a MethodDictionary(#actAsExecutor->StandardFileStream>>#actAsExecut...etc...
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#('name' 'fileID' 'buffer1')
		organization: 	a ClassOrganization
		subclasses: 	{MultiByteFileStream. AttachableFileStream}
		name: 	#StandardFileStream
		classPool: 	a Dictionary(#Registry->a WeakRegistry(<this WeakRegistry is locked>...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ file close ] in FileStream class>>detectFile:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		aBlock: 	[ self forceNewFileNamed: fileName ]
		anotherBlock: 	[ :stream | 
stream
	nextPutAll: 'system ' , sysName;
	cr;
	nextP...etc...
		file: 	StandardFileStream
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


Context>>resume:through:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		value: 	a MorphicUIManager
		firstUnwindContext: 	BlockClosure>>ensure:
		context: 	BlockClosure>>ensure:
		unwindBlock: 	[ file close ]
	Receiver's instance variables: 
		sender: 	nil
		pc: 	nil
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
chain := thisContext sender cut: ctxt.
ctxt jump ]


BlockClosure>>ensure:
	Receiver: [ anotherBlock value: file ]
	Arguments and temporary variables: 
		aBlock: 	[ file close ]
		complete: 	true
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	FileStream class>>detectFile:do:
		startpc: 	41
		numArgs: 	0


FileStream class>>detectFile:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		aBlock: 	[ self forceNewFileNamed: fileName ]
		anotherBlock: 	[ :stream | 
stream
	nextPutAll: 'system ' , sysName;
	cr;
	nextP...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>forceNewFileNamed:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMo...etc...
		aBlock: 	[ :stream | 
stream
	nextPutAll: 'system ' , sysName;
	cr;
	nextPutAll:...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr;
			nextPutAll: 'ERROR' ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	ClockSystem myApplication_withMoC-xSigpmlMocc
executeB1.
executeB...etc...
		result: 	a ClockConfigurationGraph
		resultsPath: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'
		fiacreGraph: 	nil
		sysName: 	'myApplication_withMoC-xSigpmlMocc'
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	1
		mtxFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMoC...etc...
		ltsFile: 	nil
		resultFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_with...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: r...etc...
	Arguments and temporary variables: 
		anArg: 	FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp-bri...etc...
	Receiver's instance variables: 
		outerContext: 	ClockSystem4GeMoC class>>explore:resultIn:
		startpc: 	495
		numArgs: 	0


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	ClockSystem4GeMoC class>>explore:resultIn:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProdu...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp...etc...
	Receiver's instance variables: 
		sender: 	ClockSystem4GeMoC class>>explore:resultIn:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProdu...etc...


FileDoesNotExistException(Exception)>>signal
	Receiver: FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp-bridge\myApplication_...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	MultiByteFileStream
		signalContext: 	FileDoesNotExistException(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		fileName: 	'\Users\ciprian\Playfield\GeMOC\gemoc-obp-bridge\myApplication_withMo...etc...
		readOnly: 	nil


MultiByteFileStream class(StandardFileStream class)>>forceNewFileNamed:
	Receiver: MultiByteFileStream
	Arguments and temporary variables: 
		fileName: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMo...etc...
		dir: 	nil
		fullName: 	'\Users\ciprian\Playfield\GeMOC\gemoc-obp-bridge\myApplication_withMo...etc...
		f: 	nil
	Receiver's instance variables: 
		superclass: 	StandardFileStream
		methodDict: 	a MethodDictionary(#accepts:->MultiByteFileStream>>#accepts: #ascii...etc...
		format: 	152
		layout: 	a FixedLayout
		instanceVariables: 	#('converter' 'lineEndConvention' 'wantsLineEndConversion')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MultiByteFileStream
		classPool: 	a Dictionary(#Cr->Character cr #CrLf->'

' #Lf->Character lf #LineEn...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>forceNewFileNamed:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMo...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ self forceNewFileNamed: fileName ] in FileStream class>>forceNewFileNamed:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMo...etc...
		aBlock: 	[ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ]...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>detectFile:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		aBlock: 	[ self forceNewFileNamed: fileName ]
		anotherBlock: 	[ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: st...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>forceNewFileNamed:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMo...etc...
		aBlock: 	[ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ]...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	ClockSystem myApplication_withMoC-xSigpmlMocc
executeB1.
executeB...etc...
		result: 	a ClockConfigurationGraph
		resultsPath: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'
		fiacreGraph: 	nil
		sysName: 	'myApplication_withMoC-xSigpmlMocc'
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	1
		mtxFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMoC...etc...
		ltsFile: 	nil
		resultFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_with...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>on:do:
	Receiver: [ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration explore...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileSt...etc...
	Receiver's instance variables: 
		outerContext: 	ClockSystem4GeMoC class>>explore:resultIn:
		startpc: 	186
		numArgs: 	0


ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		result: 	a ClockConfigurationGraph
		resultsPath: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'
		fiacreGraph: 	nil
		sysName: 	'myApplication_withMoC-xSigpmlMocc'
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	1
		mtxFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMoC...etc...
		ltsFile: 	nil
		resultFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_with...etc...
		aClockSystem: 	ClockSystem myApplication_withMoC-xSigpmlMocc
executeB1.
executeB...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	stream := FileStream
		readOnlyFileNamed:
			'C:\\g\\Gemoc\\trunk\\w...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler(AbstractCompiler)>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'stream := FileStream readOnlyFileNamed: ''C:\\g\\Gemoc\\trunk\\w...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	stream := FileStream
		readOnlyFileNamed:
			'C:\\g\\Gemoc\\trunk\\w...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkImage>>evaluate:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		aString: 	'stream := FileStream readOnlyFileNamed: ''C:\\g\\Gemoc\\trunk\\worksp...etc...
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection()
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aStream: 	'stream := FileStream readOnlyFileNamed: ''C:\\g\\Gemoc\\trunk\\worksp...etc...
		exceptionClassToUse: 	OCSemanticWarning
		result: 	nil
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


BlockClosure>>on:do:
	Receiver: [ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdou...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :error | self handleError: error ]
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		startpc: 	110
		numArgs: 	0


EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		result: 	nil
		aStream: 	'stream := FileStream readOnlyFileNamed: ''C:\\g\\Gemoc\\trunk\\worksp...etc...
		exceptionClassToUse: 	OCSemanticWarning
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>evaluateArguments
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		argumentString: 	'stream := FileStream readOnlyFileNamed: ''C:\\g\\Gemoc\\trunk\...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>activate
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	STCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->EvaluateCommandLineHandler>>#activate...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#EvaluateCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImport-CommandLineHandlers'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(EvaluateCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil



--- The full stack ---
StandardFileStream class(Object)>>doesNotUnderstand: #close
[ file close ] in FileStream class>>detectFile:do:
Context>>resume:through:
BlockClosure>>ensure:
FileStream class>>detectFile:do:
FileStream class>>forceNewFileNamed:do:
[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr;
			nextPutAll: 'ERROR' ] ] in ClockSystem4GeMoC class>>explore:resultIn:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
FileDoesNotExistException(Exception)>>signal
MultiByteFileStream class(StandardFileStream class)>>forceNewFileNamed:
FileStream class>>forceNewFileNamed:
[ self forceNewFileNamed: fileName ] in FileStream class>>forceNewFileNamed:do:
FileStream class>>detectFile:do:
FileStream class>>forceNewFileNamed:do:
[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
BlockClosure>>on:do:
ClockSystem4GeMoC class>>explore:resultIn:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
OpalCompiler(AbstractCompiler)>>evaluate:
SmalltalkImage>>evaluate:
[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
BlockClosure>>on:do:
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "asFileReference" is nil
16 November 2015 4:09:43.347148 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

UndefinedObject(Object)>>doesNotUnderstand: #asFileReference
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	asFileReference
		exception: 	MessageNotUnderstood: receiver of "asFileReference" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

StandardFileStream class(FileStream class)>>fullName:
	Receiver: StandardFileStream
	Arguments and temporary variables: 
		fileName: 	nil
	Receiver's instance variables: 
		superclass: 	FileStream
		methodDict: 	a MethodDictionary(#actAsExecutor->StandardFileStream>>#actAsExecut...etc...
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#('name' 'fileID' 'buffer1')
		organization: 	a ClassOrganization
		subclasses: 	{MultiByteFileStream. AttachableFileStream}
		name: 	#StandardFileStream
		classPool: 	a Dictionary(#Registry->a WeakRegistry(<this WeakRegistry is locked>...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


StandardFileStream class>>fileDoesNotExistUserHandling:
	Receiver: StandardFileStream
	Arguments and temporary variables: 
		fullFileName: 	'\Users\ciprian\Playfield\GeMOC\gemoc-obp-bridge\myApplication_wi...etc...
		selection: 	2
		newName: 	nil
	Receiver's instance variables: 
		superclass: 	FileStream
		methodDict: 	a MethodDictionary(#actAsExecutor->StandardFileStream>>#actAsExecut...etc...
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#('name' 'fileID' 'buffer1')
		organization: 	a ClassOrganization
		subclasses: 	{MultiByteFileStream. AttachableFileStream}
		name: 	#StandardFileStream
		classPool: 	a Dictionary(#Registry->a WeakRegistry(<this WeakRegistry is locked>...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


MorphicUIManager>>fileDoesNotExistsDefaultAction:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		anException: 	FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-o...etc...
	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


FileDoesNotExistException>>defaultAction
	Receiver: FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp-bridge\myApplication_...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	MultiByteFileStream
		signalContext: 	FileDoesNotExistException(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		fileName: 	'\Users\ciprian\Playfield\GeMOC\gemoc-obp-bridge\myApplication_withMo...etc...
		readOnly: 	nil


UndefinedObject>>handleSignal:
	Receiver: nil
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp...etc...
	Receiver's instance variables: 
nil

Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp...etc...
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ ...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp...etc...
	Receiver's instance variables: 
		sender: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ aCommandLinehandler activateWith: commandLine ]


FileDoesNotExistException(Exception)>>pass
	Receiver: FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp-bridge\myApplication_...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	MultiByteFileStream
		signalContext: 	FileDoesNotExistException(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		fileName: 	'\Users\ciprian\Playfield\GeMOC\gemoc-obp-bridge\myApplication_withMo...etc...
		readOnly: 	nil


EvaluateCommandLineHandler(STCommandLineHandler)>>handleError:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		error: 	FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp-bri...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


[ :error | self handleError: error ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


BlockClosure>>cull:
	Receiver: [ :error | self handleError: error ]
	Arguments and temporary variables: 
		anArg: 	FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp-bri...etc...
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		startpc: 	140
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	EvaluateCommandLineHandler>>evaluate:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifF...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp...etc...
	Receiver's instance variables: 
		sender: 	EvaluateCommandLineHandler>>evaluate:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifF...etc...


FileDoesNotExistException(Exception)>>signal
	Receiver: FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp-bridge\myApplication_...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	MultiByteFileStream
		signalContext: 	FileDoesNotExistException(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		fileName: 	'\Users\ciprian\Playfield\GeMOC\gemoc-obp-bridge\myApplication_withMo...etc...
		readOnly: 	nil


MultiByteFileStream class(StandardFileStream class)>>forceNewFileNamed:
	Receiver: MultiByteFileStream
	Arguments and temporary variables: 
		fileName: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMo...etc...
		dir: 	nil
		fullName: 	'\Users\ciprian\Playfield\GeMOC\gemoc-obp-bridge\myApplication_withMo...etc...
		f: 	nil
	Receiver's instance variables: 
		superclass: 	StandardFileStream
		methodDict: 	a MethodDictionary(#accepts:->MultiByteFileStream>>#accepts: #ascii...etc...
		format: 	152
		layout: 	a FixedLayout
		instanceVariables: 	#('converter' 'lineEndConvention' 'wantsLineEndConversion')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MultiByteFileStream
		classPool: 	a Dictionary(#Cr->Character cr #CrLf->'

' #Lf->Character lf #LineEn...etc...
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>forceNewFileNamed:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMo...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ self forceNewFileNamed: fileName ] in FileStream class>>forceNewFileNamed:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMo...etc...
		aBlock: 	[ :stream | 
stream
	nextPutAll: 'system ' , sysName;
	cr;
	nextPutAll:...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>detectFile:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		aBlock: 	[ self forceNewFileNamed: fileName ]
		anotherBlock: 	[ :stream | 
stream
	nextPutAll: 'system ' , sysName;
	cr;
	nextP...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>forceNewFileNamed:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMo...etc...
		aBlock: 	[ :stream | 
stream
	nextPutAll: 'system ' , sysName;
	cr;
	nextPutAll:...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr;
			nextPutAll: 'ERROR' ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	ClockSystem myApplication_withMoC-xSigpmlMocc
executeB1.
executeB...etc...
		result: 	a ClockConfigurationGraph
		resultsPath: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'
		fiacreGraph: 	nil
		sysName: 	'myApplication_withMoC-xSigpmlMocc'
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	1
		mtxFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMoC...etc...
		ltsFile: 	nil
		resultFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_with...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: r...etc...
	Arguments and temporary variables: 
		anArg: 	FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp-bri...etc...
	Receiver's instance variables: 
		outerContext: 	ClockSystem4GeMoC class>>explore:resultIn:
		startpc: 	495
		numArgs: 	0


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	ClockSystem4GeMoC class>>explore:resultIn:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProdu...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp...etc...
	Receiver's instance variables: 
		sender: 	ClockSystem4GeMoC class>>explore:resultIn:
		pc: 	15
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProdu...etc...


FileDoesNotExistException(Exception)>>signal
	Receiver: FileDoesNotExistException: '\Users\ciprian\Playfield\GeMOC\gemoc-obp-bridge\myApplication_...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	MultiByteFileStream
		signalContext: 	FileDoesNotExistException(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		fileName: 	'\Users\ciprian\Playfield\GeMOC\gemoc-obp-bridge\myApplication_withMo...etc...
		readOnly: 	nil


MultiByteFileStream class(StandardFileStream class)>>forceNewFileNamed:
	Receiver: MultiByteFileStream
	Arguments and temporary variables: 
		fileName: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMo...etc...
		dir: 	nil
		fullName: 	'\Users\ciprian\Playfield\GeMOC\gemoc-obp-bridge\myApplication_withMo...etc...
		f: 	nil
	Receiver's instance variables: 
		superclass: 	StandardFileStream
		methodDict: 	a MethodDictionary(#accepts:->MultiByteFileStream>>#accepts: #ascii...etc...
		format: 	152
		layout: 	a FixedLayout
		instanceVariables: 	#('converter' 'lineEndConvention' 'wantsLineEndConversion')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MultiByteFileStream
		classPool: 	a Dictionary(#Cr->Character cr #CrLf->'

' #Lf->Character lf #LineEn...etc...
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>forceNewFileNamed:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMo...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ self forceNewFileNamed: fileName ] in FileStream class>>forceNewFileNamed:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMo...etc...
		aBlock: 	[ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ]...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>detectFile:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		aBlock: 	[ self forceNewFileNamed: fileName ]
		anotherBlock: 	[ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: st...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>forceNewFileNamed:do:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMo...etc...
		aBlock: 	[ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ]...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		aClockSystem: 	ClockSystem myApplication_withMoC-xSigpmlMocc
executeB1.
executeB...etc...
		result: 	a ClockConfigurationGraph
		resultsPath: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'
		fiacreGraph: 	nil
		sysName: 	'myApplication_withMoC-xSigpmlMocc'
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	1
		mtxFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMoC...etc...
		ltsFile: 	nil
		resultFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_with...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>on:do:
	Receiver: [ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration explore...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileSt...etc...
	Receiver's instance variables: 
		outerContext: 	ClockSystem4GeMoC class>>explore:resultIn:
		startpc: 	186
		numArgs: 	0


ClockSystem4GeMoC class>>explore:resultIn:
	Receiver: ClockSystem4GeMoC
	Arguments and temporary variables: 
		result: 	a ClockConfigurationGraph
		resultsPath: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'
		fiacreGraph: 	nil
		sysName: 	'myApplication_withMoC-xSigpmlMocc'
		rccg: 	nil
		gmlFile: 	nil
		fcrGmlFile: 	nil
		runtime: 	1
		mtxFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_withMoC...etc...
		ltsFile: 	nil
		resultFile: 	'/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/myApplication_with...etc...
		aClockSystem: 	ClockSystem myApplication_withMoC-xSigpmlMocc
executeB1.
executeB...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	2
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClockSystem4GeMoC
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ClockSystem-Lib-MoCML'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	stream := FileStream
		readOnlyFileNamed:
			'C:\\g\\Gemoc\\trunk\\w...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


OpalCompiler(AbstractCompiler)>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'stream := FileStream readOnlyFileNamed: ''C:\\g\\Gemoc\\trunk\\w...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	stream := FileStream
		readOnlyFileNamed:
			'C:\\g\\Gemoc\\trunk\\w...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkImage>>evaluate:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		aString: 	'stream := FileStream readOnlyFileNamed: ''C:\\g\\Gemoc\\trunk\\worksp...etc...
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection()
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aStream: 	'stream := FileStream readOnlyFileNamed: ''C:\\g\\Gemoc\\trunk\\worksp...etc...
		exceptionClassToUse: 	OCSemanticWarning
		result: 	nil
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


BlockClosure>>on:do:
	Receiver: [ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdou...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :error | self handleError: error ]
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		startpc: 	110
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #asFileReference
StandardFileStream class(FileStream class)>>fullName:
StandardFileStream class>>fileDoesNotExistUserHandling:
MorphicUIManager>>fileDoesNotExistsDefaultAction:
FileDoesNotExistException>>defaultAction
UndefinedObject>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
FileDoesNotExistException(Exception)>>pass
EvaluateCommandLineHandler(STCommandLineHandler)>>handleError:
[ :error | self handleError: error ] in EvaluateCommandLineHandler>>evaluate:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
FileDoesNotExistException(Exception)>>signal
MultiByteFileStream class(StandardFileStream class)>>forceNewFileNamed:
FileStream class>>forceNewFileNamed:
[ self forceNewFileNamed: fileName ] in FileStream class>>forceNewFileNamed:do:
FileStream class>>detectFile:do:
FileStream class>>forceNewFileNamed:do:
[ 
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr;
			nextPutAll: 'ERROR' ] ] in ClockSystem4GeMoC class>>explore:resultIn:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
FileDoesNotExistException(Exception)>>signal
MultiByteFileStream class(StandardFileStream class)>>forceNewFileNamed:
FileStream class>>forceNewFileNamed:
[ self forceNewFileNamed: fileName ] in FileStream class>>forceNewFileNamed:do:
FileStream class>>detectFile:do:
FileStream class>>forceNewFileNamed:do:
[ 
runtime := Time millisecondsToRun: [ result := ClockCartesianProductExploration exploreModel: aClockSystem ].
resultsPath := '/Users/ciprian/Playfield/GeMOC/gemoc-obp-bridge/'.
sysName := aClockSystem systemName.	"export MTX"
mtxFile := resultsPath , sysName , '.mtx'.
FileStream forceNewFileNamed: mtxFile do: [ :stream | TraConfigurationGraph2MatrixMarket mtx: result in: stream ].
rccg := TraConfigurationGraph2LTS runOn: result.
TraRemoveInternalClocks runOn: rccg.
TraRemoveInternalEvents runOn: rccg.
fiacreGraph := TraConfigurationGraph2FiacreGraph runOn: rccg.	"export LTS"
ltsFile := resultsPath , sysName , '.lts'.
FileStream forceNewFileNamed: ltsFile do: [ :stream | TraFiacreGraph2Lts lts: fiacreGraph prefix: '{sys}1' in: stream ].	"export GML with coincidence expanded"
fcrGmlFile := resultsPath , sysName , '_fcr.gml'.
FileStream forceNewFileNamed: fcrGmlFile do: [ :stream | TraFiacreGraph2GML gml: fiacreGraph in: stream ].	"export GML without coincidence expanded"
gmlFile := resultsPath , sysName , '.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: rccg in: stream ].	"export GML full"
gmlFile := resultsPath , sysName , '_full.gml'.
FileStream forceNewFileNamed: gmlFile do: [ :stream | TraConfigurationGraph2GML gml: result in: stream ].
resultFile := resultsPath , sysName , '_csys.results'.
FileStream
	forceNewFileNamed: resultFile
	do: [ :stream | 
		stream
			nextPutAll: 'system ' , sysName;
			cr.
		stream
			nextPutAll: 'states: ' , result configurations size printString;
			cr.
		stream
			nextPutAll: 'transitions: ' , result graph size printString;
			cr.
		stream
			nextPutAll: 'time: ' , runtime printString , ' ms';
			cr ] ] in ClockSystem4GeMoC class>>explore:resultIn:
BlockClosure>>on:do:
ClockSystem4GeMoC class>>explore:resultIn:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
OpalCompiler(AbstractCompiler)>>evaluate:
SmalltalkImage>>evaluate:
[ 
result := Smalltalk evaluate: aStream.
self hasSessionChanged
	ifFalse: [ 
		self stdout
			<< result asString;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------


===============================================================================
Notice: Pharo cannot write to the changes file named C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksystem.win.core\win_vm\ClockSystem.changes.

Please check that you have write permission for this file.

You won't be able to save this image correctly until you fix this.
===============================================================================

===============================================================================
Notice: Pharo cannot write to the changes file named C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksystem.win.core\win_vm\ClockSystem.changes.

Please check that you have write permission for this file.

You won't be able to save this image correctly until you fix this.
===============================================================================
THERE_BE_DRAGONS_HERE
==== Startup Error: FileDoesNotExist: File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksystem.win.core\win_vm\test.st
17 November 2015 9:41:41.378531 am

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

FileHandle>>streamError
	Receiver: a FileHandle
	Arguments and temporary variables: 

	Receiver's instance variables: 
		reference: 	File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksyst...etc...
		writable: 	false
		id: 	nil


FileHandle>>readStream
	Receiver: a FileHandle
	Arguments and temporary variables: 

	Receiver's instance variables: 
		reference: 	File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksyst...etc...
		writable: 	false
		id: 	nil


FileSystem>>readStreamOn:
	Receiver: a FileSystem
	Arguments and temporary variables: 
		aResolvable: 	Path / 'C:' / 'g' / 'concurrency' / 'exploration' / 'plugins' / 'o...etc...
	Receiver's instance variables: 
		workingDirectory: 	Path / 'C:' / 'g' / 'concurrency' / 'exploration' / 'plugins'...etc...
		store: 	a WindowsStore


FileReference>>readStream
	Receiver: File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksystem.win.core\win_vm\tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'C:' / 'g' / 'concurrency' / 'exploration' / 'plugins' / 'org.gemo...etc...


FileReference(AbstractFileReference)>>readStreamDo:
	Receiver: File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksystem.win.core\win_vm\tes...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :stream | 
self
	handleErrorsDuring: [ 
		codeImporter := CodeImporte...etc...
		stream: 	nil
	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'C:' / 'g' / 'concurrency' / 'exploration' / 'plugins' / 'org.gemo...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	nil
		aReference: 	File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksys...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\concurrency\exploration\plugins\o...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksyst...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\concurrency\exploration\plugins\o...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksyste...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.cloc...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\concurrency\exploration\plugins\o...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\concurrency\exploration\plugins\o...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\concurrency\exploration\plugins\o...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImport-CommandLineHandlers'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler EvaluateCommandLineHandler)...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


NonInteractiveUIManager(UIManager)>>defer:
	Receiver: a NonInteractiveUIManager
	Arguments and temporary variables: 
		aBlock: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		doNotQuitOnRestart: 	false
		uiManager: 	a MorphicUIManager


PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in BasicCommandLineHandler>>activateSubCommand:
	Receiver: a BasicCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	PharoCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	BasicCommandLineHandler>>activateSubCommand:
		startpc: 	34
		numArgs: 	0


BasicCommandLineHandler>>activateSubCommand:
	Receiver: a BasicCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	PharoCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BasicCommandLineHandler>>handleSubcommand
	Receiver: a BasicCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(PharoCommandLineHandler STCommandLineHandler Eva...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BasicCommandLineHandler>>handleArgument:
	Receiver: a BasicCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in BasicCommandLineHandler>>activate
	Receiver: a BasicCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	BasicCommandLineHandler>>activate
		startpc: 	49
		numArgs: 	0


BasicCommandLineHandler>>activate
	Receiver: a BasicCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self new activate ] in BasicCommandLineHandler class>>startUp:
	Receiver: BasicCommandLineHandler
	Arguments and temporary variables: 
		resuming: 	true
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->BasicCommandLineHandler>>#activate #a...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{PharoCommandLineHandler}
		name: 	#BasicCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ self new activate ]
	Arguments and temporary variables: 
		anArg: 	true
	Receiver's instance variables: 
		outerContext: 	BasicCommandLineHandler class>>startUp:
		startpc: 	38
		numArgs: 	0


[ action cull: resuming ] in SmalltalkImage>>executeDeferredStartupActions:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		resuming: 	true
		errors: 	an OrderedCollection()
		action: 	[ self new activate ]
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection()
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


BlockClosure>>on:do:
	Receiver: [ action cull: resuming ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | self logStartupError: err into: aCollection tryDebugger...etc...
	Receiver's instance variables: 
		outerContext: 	SmalltalkImage>>executeDeferredStartupActions:
		startpc: 	77
		numArgs: 	0


SmalltalkImage>>logStartUpErrorDuring:into:tryDebugger:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		aBlock: 	[ action cull: resuming ]
		aCollection: 	an OrderedCollection()
		tryDebugger: 	false
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection()
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine



--- The full stack ---
FileHandle>>streamError
FileHandle>>readStream
FileSystem>>readStreamOn:
FileReference>>readStream
FileReference(AbstractFileReference)>>readStreamDo:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
NonInteractiveUIManager(UIManager)>>defer:
PharoCommandLineHandler class>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in BasicCommandLineHandler>>activateSubCommand:
BlockClosure>>on:do:
BasicCommandLineHandler>>activateSubCommand:
BasicCommandLineHandler>>handleSubcommand
BasicCommandLineHandler>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in BasicCommandLineHandler>>activate
BlockClosure>>on:do:
BasicCommandLineHandler>>activate
[ self new activate ] in BasicCommandLineHandler class>>startUp:
BlockClosure>>cull:
[ action cull: resuming ] in SmalltalkImage>>executeDeferredStartupActions:
BlockClosure>>on:do:
SmalltalkImage>>logStartUpErrorDuring:into:tryDebugger:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SmalltalkImage>>executeDeferredStartupActions:
SmalltalkImage>>startupImage:snapshotWorked:
SmalltalkImage>>snapshot:andQuit:
[ Smalltalk snapshot: true andQuit: false ] in WorldState class>>saveSession
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
WorldState class>>saveSession
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got startup errors: 
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
    FileDoesNotExist: File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksystem.win.core\win_vm\test.st
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
==== Startup Error: FileDoesNotExist: File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksystem.win.core\win_vm\test.st
17 November 2015 10:01:00.550461 am

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

FileHandle>>streamError
	Receiver: a FileHandle
	Arguments and temporary variables: 

	Receiver's instance variables: 
		reference: 	File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksyst...etc...
		writable: 	false
		id: 	nil


FileHandle>>readStream
	Receiver: a FileHandle
	Arguments and temporary variables: 

	Receiver's instance variables: 
		reference: 	File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksyst...etc...
		writable: 	false
		id: 	nil


FileSystem>>readStreamOn:
	Receiver: a FileSystem
	Arguments and temporary variables: 
		aResolvable: 	Path / 'C:' / 'g' / 'concurrency' / 'exploration' / 'plugins' / 'o...etc...
	Receiver's instance variables: 
		workingDirectory: 	Path / 'C:' / 'g' / 'concurrency' / 'exploration' / 'plugins'...etc...
		store: 	a WindowsStore


FileReference>>readStream
	Receiver: File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksystem.win.core\win_vm\tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'C:' / 'g' / 'concurrency' / 'exploration' / 'plugins' / 'org.gemo...etc...


FileReference(AbstractFileReference)>>readStreamDo:
	Receiver: File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksystem.win.core\win_vm\tes...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :stream | 
self
	handleErrorsDuring: [ 
		codeImporter := CodeImporte...etc...
		stream: 	nil
	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'C:' / 'g' / 'concurrency' / 'exploration' / 'plugins' / 'org.gemo...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	nil
		aReference: 	File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksys...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\concurrency\exploration\plugins\o...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksyst...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\concurrency\exploration\plugins\o...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksyste...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.cloc...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\concurrency\exploration\plugins\o...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\concurrency\exploration\plugins\o...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\concurrency\exploration\plugins\o...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImport-CommandLineHandlers'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler EvaluateCommandLineHandler)...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


NonInteractiveUIManager(UIManager)>>defer:
	Receiver: a NonInteractiveUIManager
	Arguments and temporary variables: 
		aBlock: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		doNotQuitOnRestart: 	false
		uiManager: 	a MorphicUIManager


PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in BasicCommandLineHandler>>activateSubCommand:
	Receiver: a BasicCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	PharoCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	BasicCommandLineHandler>>activateSubCommand:
		startpc: 	34
		numArgs: 	0


BasicCommandLineHandler>>activateSubCommand:
	Receiver: a BasicCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	PharoCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BasicCommandLineHandler>>handleSubcommand
	Receiver: a BasicCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(PharoCommandLineHandler STCommandLineHandler Eva...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BasicCommandLineHandler>>handleArgument:
	Receiver: a BasicCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in BasicCommandLineHandler>>activate
	Receiver: a BasicCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	BasicCommandLineHandler>>activate
		startpc: 	49
		numArgs: 	0


BasicCommandLineHandler>>activate
	Receiver: a BasicCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self new activate ] in BasicCommandLineHandler class>>startUp:
	Receiver: BasicCommandLineHandler
	Arguments and temporary variables: 
		resuming: 	true
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->BasicCommandLineHandler>>#activate #a...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{PharoCommandLineHandler}
		name: 	#BasicCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ self new activate ]
	Arguments and temporary variables: 
		anArg: 	true
	Receiver's instance variables: 
		outerContext: 	BasicCommandLineHandler class>>startUp:
		startpc: 	38
		numArgs: 	0


[ action cull: resuming ] in SmalltalkImage>>executeDeferredStartupActions:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		resuming: 	true
		errors: 	an OrderedCollection()
		action: 	[ self new activate ]
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection()
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine


BlockClosure>>on:do:
	Receiver: [ action cull: resuming ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | self logStartupError: err into: aCollection tryDebugger...etc...
	Receiver's instance variables: 
		outerContext: 	SmalltalkImage>>executeDeferredStartupActions:
		startpc: 	77
		numArgs: 	0


SmalltalkImage>>logStartUpErrorDuring:into:tryDebugger:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		aBlock: 	[ action cull: resuming ]
		aCollection: 	an OrderedCollection()
		tryDebugger: 	false
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		deferredStartupActions: 	an OrderedCollection()
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		session: 	an Object
		vm: 	a VirtualMachine



--- The full stack ---
FileHandle>>streamError
FileHandle>>readStream
FileSystem>>readStreamOn:
FileReference>>readStream
FileReference(AbstractFileReference)>>readStreamDo:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
NonInteractiveUIManager(UIManager)>>defer:
PharoCommandLineHandler class>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in BasicCommandLineHandler>>activateSubCommand:
BlockClosure>>on:do:
BasicCommandLineHandler>>activateSubCommand:
BasicCommandLineHandler>>handleSubcommand
BasicCommandLineHandler>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in BasicCommandLineHandler>>activate
BlockClosure>>on:do:
BasicCommandLineHandler>>activate
[ self new activate ] in BasicCommandLineHandler class>>startUp:
BlockClosure>>cull:
[ action cull: resuming ] in SmalltalkImage>>executeDeferredStartupActions:
BlockClosure>>on:do:
SmalltalkImage>>logStartUpErrorDuring:into:tryDebugger:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
SmalltalkImage>>executeDeferredStartupActions:
SmalltalkImage>>startupImage:snapshotWorked:
SmalltalkImage>>snapshot:andQuit:
[ Smalltalk snapshot: true andQuit: false ] in WorldState class>>saveSession
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
WorldState class>>saveSession
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got startup errors: 
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
    FileDoesNotExist: File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksystem.win.core\win_vm\test.st
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
FileDoesNotExist: File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksystem.win.core\win_vm\test.st
17 November 2015 10:01:09.349318 am

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

FileHandle>>streamError
	Receiver: a FileHandle
	Arguments and temporary variables: 

	Receiver's instance variables: 
		reference: 	File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksyst...etc...
		writable: 	false
		id: 	nil


FileHandle>>readStream
	Receiver: a FileHandle
	Arguments and temporary variables: 

	Receiver's instance variables: 
		reference: 	File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksyst...etc...
		writable: 	false
		id: 	nil


FileSystem>>readStreamOn:
	Receiver: a FileSystem
	Arguments and temporary variables: 
		aResolvable: 	Path / 'C:' / 'g' / 'concurrency' / 'exploration' / 'plugins' / 'o...etc...
	Receiver's instance variables: 
		workingDirectory: 	Path / 'C:' / 'g' / 'concurrency' / 'exploration' / 'plugins'...etc...
		store: 	a WindowsStore


FileReference>>readStream
	Receiver: File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksystem.win.core\win_vm\tes...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'C:' / 'g' / 'concurrency' / 'exploration' / 'plugins' / 'org.gemo...etc...


FileReference(AbstractFileReference)>>readStreamDo:
	Receiver: File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksystem.win.core\win_vm\tes...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :stream | 
self
	handleErrorsDuring: [ 
		codeImporter := CodeImporte...etc...
		stream: 	nil
	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'C:' / 'g' / 'concurrency' / 'exploration' / 'plugins' / 'org.gemo...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	nil
		aReference: 	File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksys...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\concurrency\exploration\plugins\o...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksyst...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\concurrency\exploration\plugins\o...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.clocksyste...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ C:\g\concurrency\exploration\plugins\org.gemoc.mocc.cloc...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\concurrency\exploration\plugins\o...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\concurrency\exploration\plugins\o...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\concurrency\exploration\plugins\o...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImport-CommandLineHandlers'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler EvaluateCommandLineHandler)...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1902@1035)
		canvas: 	a FormCanvas on: DisplayScreen(1902x1035x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	23141204
		lastStepMessage: 	nil
		lastCycleTime: 	776
		alarms: 	a Heap()
		lastAlarmTime: 	776
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1902@1035)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(173539328) a Sp...etc...
		fullBounds: 	(0@0) corner: (1902@1035)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1902@1035)
		canvas: 	a FormCanvas on: DisplayScreen(1902x1035x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	23141204
		lastStepMessage: 	nil
		lastCycleTime: 	776
		alarms: 	a Heap()
		lastAlarmTime: 	776
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1902@1035)
		canvas: 	a FormCanvas on: DisplayScreen(1902x1035x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	23141204
		lastStepMessage: 	nil
		lastCycleTime: 	776
		alarms: 	a Heap()
		lastAlarmTime: 	776
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1902@1035)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a GLMSystemWindow(173539328) a Sp...etc...
		fullBounds: 	(0@0) corner: (1902@1035)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	an AlphaImageMorph(658243584)
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
FileHandle>>streamError
FileHandle>>readStream
FileSystem>>readStreamOn:
FileReference>>readStream
FileReference(AbstractFileReference)>>readStreamDo:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------


===============================================================================
Notice: Errors in script loaded from C:\g\Gemoc\trunk\workspaces\modeling-Sigpml\SigpmlModelingTuto\clocksystem-files\clockSystemScript.st
===============================================================================
THERE_BE_DRAGONS_HERE
==== Startup Error: FileDoesNotExistException: 'C:\g\Gemoc\trunk\workspaces\modeling-Sigpml\SigpmlModelingTuto\clocksystem-files'
17 November 2015 10:30:39.740032 am

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
NBCogit NativeBoost-CogPlugin-HolgerHansPeterFreyther.21 uuid: e0df6e2d-5694-40e2-8035-dc217200b424 Sep 25 2014
https://github.com/pharo-project/pharo-vm.git Commit: 81b5d19917dcb78f22482a780deec48c53738396 Date: 2014-09-20 14:36:18 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14858

Image: Pharo4.0 [Latest update: #40624]

MultiByteFileStream class(StandardFileStream class)>>readOnlyFileNamed:
	Receiver: MultiByteFileStream
	Arguments and temporary variables: 
		fileName: 	'C:\g\Gemoc\trunk\workspaces\modeling-Sigpml\SigpmlModelingTuto\clock...etc...
		fullName: 	'C:\g\Gemoc\trunk\workspaces\modeling-Sigpml\SigpmlModelingTuto\clock...etc...
		f: 	nil
	Receiver's instance variables: 
		superclass: 	StandardFileStream
		methodDict: 	a MethodDictionary(#accepts:->MultiByteFileStream>>#accepts: #ascii...etc...
		format: 	152
		layout: 	a FixedLayout
		instanceVariables: 	#('converter' 'lineEndConvention' 'wantsLineEndConversion')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MultiByteFileStream
		classPool: 	a Dictionary(#Cr->Character cr #CrLf->'

' #Lf->Character lf #LineEn...etc...
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


FileStream class>>readOnlyFileNamed:
	Receiver: FileStream
	Arguments and temporary variables: 
		fileName: 	'C:\\g\\Gemoc\\trunk\\workspaces\\modeling-Sigpml\\SigpmlModelingTuto...etc...
	Receiver's instance variables: 
		superclass: 	ReadWriteStream
		methodDict: 	a MethodDictionary(#asBinaryOrTextStream->FileStream>>#asBinaryOrTe...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#('rwmode')
		organization: 	a ClassOrganization
		subclasses: 	{StandardFileStream}
		name: 	#FileStream
		classPool: 	a Dictionary(#Stderr->MultiByteFileStream: 'C:\g\concurrency\explora...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	stream := FileStream
		readOnlyFileNamed: 'C:\\g\\Gemoc\\trunk\\work...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


DoItDeclaration>>importFor:
	Receiver: a DoItDeclaration(stream := FileStream readOnlyFileNamed:'C:\\g\\Gemoc\\trunk\\workspaces\...etc...
	Arguments and temporary variables: 
		requestor: 	a FileCompilerRequestor
	Receiver's instance variables: 
		contents: 	'stream := FileStream readOnlyFileNamed:''C:\\g\\Gemoc\\trunk\\worksp...etc...


[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
		declaration: 	a DoItDeclaration(stream := FileStream readOnlyFileNamed:'C:\\g\\G...etc...
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: 'C:\g\Gemoc\trunk\workspaces\modeling-Sigpml\S...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(stream := FileStream r...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


OrderedCollection>>do:
	Receiver: an OrderedCollection(a DoItDeclaration(stream := FileStream readOnlyFileNamed:'C:\\g\\Gemo...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a DoItDeclaration(stream := FileStream readOnlyFileNamed:'C:\\g...etc...
		firstIndex: 	1
		lastIndex: 	1


CodeImporter>>evaluate
	Receiver: a CodeImporter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		readStream: 	MultiByteFileStream: 'C:\g\Gemoc\trunk\workspaces\modeling-Sigpml\S...etc...
		codeDeclarations: 	an OrderedCollection(a DoItDeclaration(stream := FileStream r...etc...
		parserClass: 	ChunkFileFormatParser
		requestor: 	a FileCompilerRequestor


[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aReference: 	File @ C:\g\Gemoc\trunk\workspaces\modeling-Sigpml\SigpmlModelingTu...etc...
		codeImporter: 	a CodeImporter
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\Gemoc\trunk\workspaces\modeling-S...etc...


BlockClosure>>on:do:
	Receiver: [ codeImporter evaluate ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | self handleError: e reference: aReference ]
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFile:
		startpc: 	81
		numArgs: 	0


STCommandLineHandler>>handleErrorsDuring:reference:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		aBlock: 	[ codeImporter evaluate ]
		aReference: 	File @ C:\g\Gemoc\trunk\workspaces\modeling-Sigpml\SigpmlModelingTu...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\Gemoc\trunk\workspaces\modeling-S...etc...


STCommandLineHandler>>installSourceFile:
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		codeImporter: 	a CodeImporter
		aReference: 	File @ C:\g\Gemoc\trunk\workspaces\modeling-Sigpml\SigpmlModelingTu...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\Gemoc\trunk\workspaces\modeling-S...etc...


[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 
		reference: 	File @ C:\g\Gemoc\trunk\workspaces\modeling-Sigpml\SigpmlModelingTut...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\Gemoc\trunk\workspaces\modeling-S...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(File @ C:\g\Gemoc\trunk\workspaces\modeling-Sigpml\SigpmlModelingTuto...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :reference | self installSourceFile: reference ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(File @ C:\g\Gemoc\trunk\workspaces\modeling-Sigpml\SigpmlModeli...etc...
		firstIndex: 	1
		lastIndex: 	1


[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\Gemoc\trunk\workspaces\modeling-S...etc...


BlockClosure>>ensure:
	Receiver: [ sourceFiles do: [ :reference | self installSourceFile: reference ] ]
	Arguments and temporary variables: 
		aBlock: 	[ sourceFiles := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	STCommandLineHandler>>installSourceFiles
		startpc: 	34
		numArgs: 	0


STCommandLineHandler>>installSourceFiles
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\Gemoc\trunk\workspaces\modeling-S...etc...


STCommandLineHandler>>activate
	Receiver: a STCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	an OrderedCollection(File @ C:\g\Gemoc\trunk\workspaces\modeling-S...etc...


STCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: STCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	CommandLineHandler
		methodDict: 	a MethodDictionary(#activate->STCommandLineHandler>>#activate #end-...etc...
		format: 	140
		layout: 	a FixedLayout
		instanceVariables: 	#(#sourceFiles)
		organization: 	a ClassOrganization
		subclasses: 	{EvaluateCommandLineHandler}
		name: 	#STCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImport-CommandLineHandlers'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	34
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	STCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(STCommandLineHandler EvaluateCommandLineHandler)...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	49
		numArgs: 	0


PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


NonInteractiveUIManager(UIManager)>>defer:
	Receiver: a NonInteractiveUIManager
	Arguments and temporary variables: 
		aBlock: 	[ super activateWith: aCommandLine ]
	Receiver's instance variables: 
		doNotQuitOnRestart: 	false
		uiManager: 	a MorphicUIManager


PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler'
		traitComposition: 	{}
		localSelectors: 	nil


[ aCommandLinehandler activateWith: commandLine ] in BasicCommandLineHandler>>activateSubCommand:
	Receiver: a BasicCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	PharoCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	BasicCommandLineHandler>>activateSubCommand:
		startpc: 	34
		numArgs: 	0


BasicCommandLineHandler>>activateSubCommand:
	Receiver: a BasicCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	PharoCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BasicCommandLineHandler>>handleSubcommand
	Receiver: a BasicCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(PharoCommandLineHandler STCommandLineHandler Eva...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BasicCommandLineHandler>>handleArgument:
	Receiver: a BasicCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in BasicCommandLineHandler>>activate
	Receiver: a BasicCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a Session
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | argument...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit ]
	Receiver's instance variables: 
		outerContext: 	BasicCommandLineHandler>>activate
		startpc: 	49
		numArgs: 	0



--- The full stack ---
MultiByteFileStream class(StandardFileStream class)>>readOnlyFileNamed:
FileStream class>>readOnlyFileNamed:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
DoItDeclaration>>importFor:
[ :declaration | 
requestor ifNotNil: [ requestor contents: declaration contents ].
value := declaration importFor: requestor ] in CodeImporter>>evaluate
OrderedCollection>>do:
CodeImporter>>evaluate
[ codeImporter evaluate ] in STCommandLineHandler>>installSourceFile:
BlockClosure>>on:do:
STCommandLineHandler>>handleErrorsDuring:reference:
STCommandLineHandler>>installSourceFile:
[ :reference | self installSourceFile: reference ] in [ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
OrderedCollection>>do:
[ sourceFiles do: [ :reference | self installSourceFile: reference ] ] in STCommandLineHandler>>installSourceFiles
BlockClosure>>ensure:
STCommandLineHandler>>installSourceFiles
STCommandLineHandler>>activate
STCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activate
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
NonInteractiveUIManager(UIManager)>>defer:
PharoCommandLineHandler class>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in BasicCommandLineHandler>>activateSubCommand:
BlockClosure>>on:do:
BasicCommandLineHandler>>activateSubCommand:
BasicCommandLineHandler>>handleSubcommand
BasicCommandLineHandler>>handleArgument:
[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ] in BasicCommandLineHandler>>activate
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BasicCommandLineHandler>>activate
[ self new activate ] in BasicCommandLineHandler class>>startUp:
BlockClosure>>cull:
[ action cull: resuming ] in SmalltalkImage>>executeDeferredStartupActions:
BlockClosure>>on:do:
SmalltalkImage>>logStartUpErrorDuring:into:tryDebugger:
SmalltalkImage>>executeDeferredStartupActions:
SmalltalkImage>>startupImage:snapshotWorked:
SmalltalkImage>>snapshot:andQuit:
[ Smalltalk snapshot: true andQuit: false ] in WorldState class>>saveSession
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
WorldState class>>saveSession
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
[ 
World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got startup errors: 
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
    FileDoesNotExistException: 'C:\g\Gemoc\trunk\workspaces\modeling-Sigpml\SigpmlModelingTuto\clocksystem-files'
-------------------------------------------------------------------------------

