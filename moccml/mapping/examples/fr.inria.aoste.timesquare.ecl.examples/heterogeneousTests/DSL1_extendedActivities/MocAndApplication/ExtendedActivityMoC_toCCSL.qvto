import fr.inria.aoste.timesquare.ecl.EclQVToHelper;

	
modeltype Ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
//modeltype pivot uses 'http://www.eclipse.org/ocl/3.1.0/Pivot';
	   
modeltype inMM uses 'http://www.eclipse.org/uml2/4.0.0/UML';
modeltype QVT uses 'http://www.eclipse.org/QVT/1.0.0/Operational';//http://www.eclipse.org/m2m/qvt/oml/1.0.0/Stdlib';//http://www.eclipse.org/qvt/1.0/ImperativeOCL'; 
modeltype TimeModel uses 'http://fr.inria.aoste.timemodel';

	

transformation doUML_To_CCSL(in inM : inMM, out TimeModel);

property theCCSLSpec			:TimeModel::CCSLModel::ClockConstraintSystem = null;
property theMainBlock			:TimeModel::CCSLModel::Block				 = null;

property Kernel_Integer 	: TimeModel::BasicType::Type		= null;
property Kernel_Clock_Type 	: TimeModel::BasicType::Type		= null;

property seqOfRelationDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration)    = Sequence{};
property seqOfAbstractEntity :		Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)    = Sequence{};
property seqOfExpressionDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration)    = Sequence{};


query identifyUserRelations() {
	var kernelTypes :  	Sequence(TimeModel::BasicType::Type) := Sequence{};
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::BasicType::Type];

	Kernel_Integer 					:= kernelTypes[name='int']->asSequence()->first();
	Kernel_Clock_Type				:= kernelTypes[name='clock']->asSequence()->first();	
	return;
}


//usefull function :)
	mapping Real::Real2Integer(n: String) :TimeModel::BasicType::IntegerElement {
		name:= n;
		type:= Kernel_Integer;
		value := self.round();

		end{
			theMainBlock.elements += result;
		}
	}

main() {
	identifyUserRelations();
	inM.rootObjects()[inMM::Package]->asSequence()->first()-> map uml2CCSL();
	}

			
			

	mapping inMM::Package::uml2CCSL() : TimeModel::CCSLModel::ClockConstraintSystem {
	    theCCSLSpec := result;
	    name := self.name;
	    theMainBlock :=object TimeModel::CCSLModel::Block{
	    	name := "mainBlock";
	    };
	    subBlock += theMainBlock;
	    result.superBlock := theMainBlock;

		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib';
			alias := 'kernel';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib';
			alias := 'CCSL';
			
		}; 
	
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};

		inM.rootObjects().allSubobjects()->including(self)[ Class ]->map referenceClock2Clock();
		inM.rootObjects().allSubobjects()->including(self)[ InputPin ]->map dataRead2Clock();
		inM.rootObjects().allSubobjects()->including(self)[ OutputPin ]->map dataWrite2Clock();
		inM.rootObjects().allSubobjects()->including(self)[ ControlNode ]->map startIt2Clock();
		inM.rootObjects().allSubobjects()->including(self)[ ControlNode ]->map finishIt2Clock();
		inM.rootObjects().allSubobjects()->including(self)[ Activity ]->map startActivity2Clock();
		inM.rootObjects().allSubobjects()->including(self)[ Activity ]->map finishActivity2Clock();
		inM.rootObjects().allSubobjects()->including(self)[ Action ]->map startIt2Clock();
		inM.rootObjects().allSubobjects()->including(self)[ Action ]->map finishIt2Clock();
		
		inM.rootObjects().allSubobjects()->including(self)[ ObjectFlow ]->map consumeonlyIfproduced112consumeonlyIfproduced();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ ObjectFlow ]->map consumeMeansStart112consumeMeansStart();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ ObjectFlow ]->map consumeMeansControl112consumeMeansControl();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Action ]->map waitControlToExecute262waitControlToExecute();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Action ]->map StartAlternatesWithFinish12StartAlternatesWithFinish();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Action ]->map startAsSoonAsAllDataRead392startAsSoonAsAllDataRead();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Action ]->map Select_startAsSoonAsOneDataRead392Select_startAsSoonAsOneDataRead();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Action ]->map lastDataWroteCauseStop392lastDataWroteCauseStop();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Action ]->map startBeforeWritingAndWirteOnlyOnce412startBeforeWritingAndWirteOnlyOnce();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Action ]->map Route_oneDataWroteCauseStop392Route_oneDataWroteCauseStop();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Action ]->map Route_startAlternesWithoneDataWrote392Route_startAlternesWithoneDataWrote();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Action ]->map Route_onlyOneRouteSelected312Route_onlyOneRouteSelected();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Action ]->map Route_startBeforeWritingAndWriteOnlyOnce412Route_startBeforeWritingAndWriteOnlyOnce();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Activity ]->map startCausesInit12startCausesInit();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Activity ]->map lastFinalNodeStopActivity252lastFinalNodeStopActivity();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Activity ]->map noReEntrance12noReEntrance();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ DecisionNode ]->map onlyOneDecision12onlyOneDecision();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ DecisionNode ]->map DecisionCausalities172DecisionCausalities();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ MergeNode ]->map MergeCausalities162MergeCausalities();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ ControlNode ]->map instantaneousExecution12instantaneousExecution();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ ControlNode ]->map waitAllInputsToStart372waitAllInputsToStart();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ ForkNode ]->map allOutputsSynchronous12allOutputsSynchronous();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ ForkNode ]->map startCausesControlOnAllOutputs122startCausesControlOnAllOutputs();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Class ]->map periodicExec252periodicExec();
		
	}





//create the expressions...
	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::Action::intermediate_lastDataRead2Expression(an1 : uml::InputPin, an2 : uml::InputPin, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_lastDataRead'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Sup")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_dataRead']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_dataRead']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::Action::intermediate_lastDataRead2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : uml::InputPin, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_lastDataRead'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Sup")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_dataRead']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::Action::lastDataRead2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(uml::InputPin) := self.input->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_lastDataRead2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_lastDataRead2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_lastDataRead2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::Action::intermediate_unionOfDataRead2Expression(an1 : uml::InputPin, an2 : uml::InputPin, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_unionOfDataRead'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_dataRead']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_dataRead']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::Action::intermediate_unionOfDataRead2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : uml::InputPin, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_unionOfDataRead'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_dataRead']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::Action::unionOfDataRead2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(uml::InputPin) := self.input->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_unionOfDataRead2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_unionOfDataRead2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_unionOfDataRead2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::Action::intermediate_allDataWrote2Expression(an1 : uml::OutputPin, an2 : uml::OutputPin, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_allDataWrote'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Sup")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_dataWrite']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_dataWrite']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::Action::intermediate_allDataWrote2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : uml::OutputPin, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_allDataWrote'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Sup")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_dataWrite']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::Action::allDataWrote2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(uml::OutputPin) := self.output->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allDataWrote2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allDataWrote2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allDataWrote2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::Action::intermediate_firstDataWrote2Expression(an1 : uml::OutputPin, an2 : uml::OutputPin, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_firstDataWrote'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Inf")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_dataWrite']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Inf']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Inf).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_dataWrite']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Inf']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Inf).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::Action::intermediate_firstDataWrote2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : uml::OutputPin, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_firstDataWrote'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Inf")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Inf']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Inf).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_dataWrite']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Inf']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Inf).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::Action::firstDataWrote2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(uml::OutputPin) := self.output->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_firstDataWrote2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_firstDataWrote2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_firstDataWrote2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::Action::intermediate_unionOfDataWrote2Expression(an1 : uml::OutputPin, an2 : uml::OutputPin, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_unionOfDataWrote'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_dataWrite']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_dataWrite']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::Action::intermediate_unionOfDataWrote2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : uml::OutputPin, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_unionOfDataWrote'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_dataWrite']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::Action::unionOfDataWrote2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(uml::OutputPin) := self.output->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_unionOfDataWrote2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_unionOfDataWrote2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_unionOfDataWrote2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::Action::intermediate_unionOfDataWrote22Expression(an1 : uml::OutputPin, an2 : uml::OutputPin, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_unionOfDataWrote2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_dataWrite']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_dataWrite']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::Action::intermediate_unionOfDataWrote22Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : uml::OutputPin, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_unionOfDataWrote2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_dataWrite']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::Action::unionOfDataWrote22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(uml::OutputPin) := self.output->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_unionOfDataWrote22Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_unionOfDataWrote22Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_unionOfDataWrote22Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::Action::intermediate_unionOfDataWrote32Expression(an1 : uml::OutputPin, an2 : uml::OutputPin, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_unionOfDataWrote3'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_dataWrite']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_dataWrite']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::Action::intermediate_unionOfDataWrote32Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : uml::OutputPin, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_unionOfDataWrote3'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_dataWrite']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::Action::unionOfDataWrote32Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(uml::OutputPin) := self.output->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_unionOfDataWrote32Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_unionOfDataWrote32Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_unionOfDataWrote32Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::Activity::intermediate_firstFinalNode2Expression(an1 : uml::FinalNode, an2 : uml::FinalNode, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_firstFinalNode'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Inf")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_finishIt']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Inf']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Inf).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_finishIt']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Inf']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Inf).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::Activity::intermediate_firstFinalNode2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : uml::FinalNode, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_firstFinalNode'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Inf")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Inf']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Inf).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_finishIt']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Inf']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Inf).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::Activity::firstFinalNode2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(uml::FinalNode) := self.node->select(n|n.oclIsKindOf(FinalNode))->asSequence()->first().oclAsType(FinalNode)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_firstFinalNode2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_firstFinalNode2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_firstFinalNode2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::DecisionNode::intermediate_allStartChoices2Expression(an1 : uml::Action, an2 : uml::Action, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_allStartChoices'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_startIt']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_startIt']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::DecisionNode::intermediate_allStartChoices2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : uml::Action, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_allStartChoices'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_startIt']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::DecisionNode::allStartChoices2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(uml::Action) := self.outgoing->asSequence().target.oclAsType(Action)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allStartChoices2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allStartChoices2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allStartChoices2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::MergeNode::intermediate_unionOfIncomes2Expression(an1 : uml::Action, an2 : uml::Action, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_unionOfIncomes'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_finishIt']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_finishIt']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::MergeNode::intermediate_unionOfIncomes2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : uml::Action, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_unionOfIncomes'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_finishIt']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::MergeNode::unionOfIncomes2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(uml::Action) := self.incoming.source.oclAsType(Action)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_unionOfIncomes2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_unionOfIncomes2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_unionOfIncomes2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::ControlNode::intermediate_incomingFinished2Expression(an1 : uml::ActivityNode, an2 : uml::ActivityNode, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_incomingFinished'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Sup")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_finishIt']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_finishIt']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::ControlNode::intermediate_incomingFinished2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : uml::ActivityNode, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_incomingFinished'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Sup")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_finishIt']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::ControlNode::incomingFinished2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(uml::ActivityNode) := self.incoming.source->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_incomingFinished2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_incomingFinished2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_incomingFinished2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::ForkNode::intermediate_allOutputControl2Expression(an1 : uml::ActivityNode, an2 : uml::ActivityNode, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_allOutputControl'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Intersection")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_finishIt']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Intersection']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Intersection).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_finishIt']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Intersection']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Intersection).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::ForkNode::intermediate_allOutputControl2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : uml::ActivityNode, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_allOutputControl'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Intersection")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Intersection']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Intersection).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_finishIt']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Intersection']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Intersection).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::ForkNode::allOutputControl2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(uml::ActivityNode) := self.outgoing.target->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allOutputControl2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allOutputControl2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allOutputControl2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::Class::periodicClock2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'_Periodic_periodicClock';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Periodic")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_referenceClock']->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicBaseClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'Periodic']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := 10 -> map Real2Integer(self.name+self.name+"_10")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicPeriod' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'Periodic']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := 1 -> map Real2Integer(self.name+self.name+"_1")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicOffset' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'Periodic']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}




	 	mapping inMM::Class::referenceClock2Clock() :TimeModel::Clock {
			name:= self.name+'_referenceClock';
			
			tickingEvent := object TimeModel::Event{
				name := 'evt_'+self.name+'_referenceClock';
				kind := TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM::InputPin::dataRead2Clock() :TimeModel::Clock {
			name:= self.name+'_dataRead';
			
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				name := 'evt_'+self.name+'_dataRead';
				kind := TimeModel::EventKind::consume;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM::OutputPin::dataWrite2Clock() :TimeModel::Clock {
			name:= self.name+'_dataWrite';
			
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				name := 'evt_'+self.name+'_dataWrite';
				kind := TimeModel::EventKind::produce;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM::ControlNode::startIt2Clock() :TimeModel::Clock {
			name:= self.name+'_startIt';
			
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				name := 'evt_'+self.name+'_startIt';
				kind := TimeModel::EventKind::start;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM::ControlNode::finishIt2Clock() :TimeModel::Clock {
			name:= self.name+'_finishIt';
			
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				name := 'evt_'+self.name+'_finishIt';
				kind := TimeModel::EventKind::start;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM::Activity::startActivity2Clock() :TimeModel::Clock {
			name:= self.name+'_startActivity';
			
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				name := 'evt_'+self.name+'_startActivity';
				kind := TimeModel::EventKind::start;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM::Activity::finishActivity2Clock() :TimeModel::Clock {
			name:= self.name+'_finishActivity';
			
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				name := 'evt_'+self.name+'_finishActivity';
				kind := TimeModel::EventKind::finish;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM::Action::startIt2Clock() :TimeModel::Clock {
			name:= self.name+'_startIt';
			
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				name := 'evt_'+self.name+'_startIt';
				kind := TimeModel::EventKind::start;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM::Action::finishIt2Clock() :TimeModel::Clock {
			name:= self.name+'_finishIt';
			
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				name := 'evt_'+self.name+'_finishIt';
				kind := TimeModel::EventKind::finish;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		

//relation stuff		
	
		mapping inMM::ObjectFlow::consumeonlyIfproduced112consumeonlyIfproduced(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { (self.target.oclIsKindOf(InputPin)) }
		{
		 	name := self.name+"Precedes_consumeonlyIfproduced";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.source.oclAsType(OutputPin).name+'_dataWrite']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.target.oclAsType(InputPin).name+'_dataRead']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::ObjectFlow::consumeMeansStart112consumeMeansStart(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { (self.target.oclIsKindOf(Action)) }
		{
		 	name := self.name+"Precedes_consumeMeansStart";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.source.oclAsType(OutputPin).name+'_dataWrite']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.target.oclAsType(Action).name+'_startIt']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::ObjectFlow::consumeMeansControl112consumeMeansControl(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { (self.target.oclIsKindOf(ControlNode)) }
		{
		 	name := self.name+"Precedes_consumeMeansControl";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.source.oclAsType(OutputPin).name+'_dataWrite']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.target.oclAsType(ControlNode).name+'_startIt']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM::Action::waitControlToExecute262waitControlToExecute(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { (self.incoming->size() > 0) }
		{
		 	name := self.name+"Causes_waitControlToExecute";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Causes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.incoming->asSequence()->first().source.name+'_finishIt']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_startIt']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::Action::StartAlternatesWithFinish12StartAlternatesWithFinish(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Alternates_StartAlternatesWithFinish";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_startIt']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_finishIt']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::Action::startAsSoonAsAllDataRead392startAsSoonAsAllDataRead(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { (self.getAppliedStereotypes()->select(s | s.name = 'Select')->size() = 0 and (self.input->size() > 0)) }
		{
		 	name := self.name+"Causes_startAsSoonAsAllDataRead";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Causes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map lastDataRead2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_startIt']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::Action::Select_startAsSoonAsOneDataRead392Select_startAsSoonAsOneDataRead(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { (self.getAppliedStereotypes()->select(s | s.name = 'Select')->size() = 1 and (self.input->size() > 0)) }
		{
		 	name := self.name+"Causes_Select_startAsSoonAsOneDataRead";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Causes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map unionOfDataRead2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_startIt']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::Action::lastDataWroteCauseStop392lastDataWroteCauseStop(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { (self.getAppliedStereotypes()->select(s | s.name = 'Route')->size() = 0 and (self.output->size() > 0)) }
		{
		 	name := self.name+"Alternates_lastDataWroteCauseStop";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allDataWrote2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_finishIt']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::Action::startBeforeWritingAndWirteOnlyOnce412startBeforeWritingAndWirteOnlyOnce(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { ((self.getAppliedStereotypes()->select(s | s.name = 'Route')->size() = 0) and
		(self.output->size() > 0)) }
		{
		 	name := self.name+"Alternates_startBeforeWritingAndWirteOnlyOnce";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_startIt']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map firstDataWrote2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::Action::Route_oneDataWroteCauseStop392Route_oneDataWroteCauseStop(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { (self.getAppliedStereotypes()->select(s | s.name = 'Route')->size() = 1 and (self.output->size() > 0)) }
		{
		 	name := self.name+"Alternates_Route_oneDataWroteCauseStop";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map unionOfDataWrote2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_finishIt']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::Action::Route_startAlternesWithoneDataWrote392Route_startAlternesWithoneDataWrote(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { (self.getAppliedStereotypes()->select(s | s.name = 'Route')->size() = 1 and (self.output->size() > 0)) }
		{
		 	name := self.name+"Alternates_Route_startAlternesWithoneDataWrote";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_startIt']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map unionOfDataWrote22Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		
		theMainBlock.relations += result;
		}
		
	
	
//Create an intermediate relation
	mapping inMM::Action::intermediate_Route_onlyOneRouteSelected312Route_onlyOneRouteSelected(an1 : uml::OutputPin, an2 : uml::OutputPin, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := self.name+'intermediate_Route_onlyOneRouteSelected'+nbi.toString()+"_"+nbj.toString();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_dataWrite']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_dataWrite']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM::Action::Route_onlyOneRouteSelected312Route_onlyOneRouteSelected()
	{
		init{
			var sources : Sequence(uml::OutputPin) := self.output->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_Route_onlyOneRouteSelected312Route_onlyOneRouteSelected(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	
		mapping inMM::Action::Route_startBeforeWritingAndWriteOnlyOnce412Route_startBeforeWritingAndWriteOnlyOnce(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { ((self.getAppliedStereotypes()->select(s | s.name = 'Route')->size() = 1) and
		(self.output->size() > 0)) }
		{
		 	name := self.name+"Alternates_Route_startBeforeWritingAndWriteOnlyOnce";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_startIt']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map unionOfDataWrote32Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM::Activity::startCausesInit12startCausesInit(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Causes_startCausesInit";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Causes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_startActivity']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.node->select(n|n.oclIsKindOf(InitialNode))->asSequence()->first().oclAsType(InitialNode).name+'_startIt']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::Activity::lastFinalNodeStopActivity252lastFinalNodeStopActivity(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Causes_lastFinalNodeStopActivity";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Causes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map firstFinalNode2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_finishActivity']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::Activity::noReEntrance12noReEntrance(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Alternates_noReEntrance";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_startActivity']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_finishActivity']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
	
//Create an intermediate relation
	mapping inMM::DecisionNode::intermediate_onlyOneDecision12onlyOneDecision(an1 : uml::Action, an2 : uml::Action, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := self.name+'intermediate_onlyOneDecision'+nbi.toString()+"_"+nbj.toString();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_startIt']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_startIt']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM::DecisionNode::onlyOneDecision12onlyOneDecision()
	{
		init{
			var sources : Sequence(uml::Action) := self.outgoing->asSequence().target.oclAsType(Action)->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_onlyOneDecision12onlyOneDecision(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	
		mapping inMM::DecisionNode::DecisionCausalities172DecisionCausalities(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Alternates_DecisionCausalities";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_startIt']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allStartChoices2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM::MergeNode::MergeCausalities162MergeCausalities(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Precedes_MergeCausalities";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map unionOfIncomes2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_startIt']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM::ControlNode::instantaneousExecution12instantaneousExecution(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Coincides_instantaneousExecution";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_startIt']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_finishIt']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::ControlNode::waitAllInputsToStart372waitAllInputsToStart(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { ((self.incoming->size() > 0) and self.incoming->asSequence()->first().source.oclIsKindOf(Action)) }
		{
		 	name := self.name+"Causes_waitAllInputsToStart";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Causes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.incoming->asSequence()->first().source.name+'_finishIt']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_startIt']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
	
//Create an intermediate relation
	mapping inMM::ForkNode::intermediate_allOutputsSynchronous12allOutputsSynchronous(an1 : uml::ActivityNode, an2 : uml::ActivityNode, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := self.name+'intermediate_allOutputsSynchronous'+nbi.toString()+"_"+nbj.toString();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_finishIt']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Coincidence).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_finishIt']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Coincidence).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM::ForkNode::allOutputsSynchronous12allOutputsSynchronous()
	{
		init{
			var sources : Sequence(uml::ActivityNode) := self.outgoing.target->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_allOutputsSynchronous12allOutputsSynchronous(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	
		mapping inMM::ForkNode::startCausesControlOnAllOutputs122startCausesControlOnAllOutputs(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Causes_startCausesControlOnAllOutputs";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Causes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_finishIt']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allOutputControl2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM::Class::periodicExec252periodicExec(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { (not self.oclIsKindOf(Behavior)) }
		{
		 	name := self.name+"Coincides_periodicExec";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map periodicClock2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.ownedBehavior->select(b|b.oclIsKindOf(Activity))->asSequence()->first().oclAsType(Activity).name+'_startActivity']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		

