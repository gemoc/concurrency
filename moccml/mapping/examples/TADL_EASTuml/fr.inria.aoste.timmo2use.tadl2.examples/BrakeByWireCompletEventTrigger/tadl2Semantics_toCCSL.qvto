import fr.inria.aoste.timesquare.ecl.EclQVToHelper;

	
modeltype Ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
//modeltype pivot uses 'http://www.eclipse.org/ocl/3.1.0/Pivot';
	   
modeltype inMM uses 'http://fr.inria.aoste.timmo2use.tadl2.TimingExpressions';
modeltype QVT uses 'http://www.eclipse.org/QVT/1.0.0/Operational';//http://www.eclipse.org/m2m/qvt/oml/1.0.0/Stdlib';//http://www.eclipse.org/qvt/1.0/ImperativeOCL'; 
modeltype TimeModel uses 'http://fr.inria.aoste.timemodel';

	

transformation dohttp_To_CCSL(in inM : inMM, out TimeModel);

property theCCSLSpec			:TimeModel::CCSLModel::ClockConstraintSystem = null;
property theMainBlock			:TimeModel::CCSLModel::Block				 = null;

property Kernel_Integer 	: TimeModel::BasicType::Type		= null;
property Kernel_Clock_Type 	: TimeModel::BasicType::Type		= null;

property seqOfRelationDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration)    = Sequence{};
property seqOfAbstractEntity :		Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)    = Sequence{};
property seqOfExpressionDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration)    = Sequence{};


query identifyUserRelations() {
	var kernelTypes :  	Sequence(TimeModel::BasicType::Type) := Sequence{};
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/resource/fr.inria.aoste.timmo2use.tadl2.examples/BrakeByWireOneWheel/tadl2.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/resource/fr.inria.aoste.timmo2use.tadl2.examples/BrakeByWireOneWheel/tadl2.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/resource/fr.inria.aoste.timmo2use.tadl2.examples/BrakeByWireOneWheel/tadl2.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/resource/fr.inria.aoste.timmo2use.tadl2.examples/BrakeByWireOneWheel/tadl2.ccslLib")[TimeModel::BasicType::Type];

	Kernel_Integer 					:= kernelTypes[name='int']->asSequence()->first();
	Kernel_Clock_Type				:= kernelTypes[name='clock']->asSequence()->first();	
	return;
}


//usefull function :)
	mapping Real::Real2Integer(n: String) :TimeModel::BasicType::IntegerElement {
		name:= n;
		type:= Kernel_Integer;
		value := self.round();

		end{
			theMainBlock.elements += result;
		}
	}

main() {
	identifyUserRelations();
	inM.rootObjects()[inMM::Timing]->asSequence()->first()-> map TimingExpressions2CCSL();
	}

			
			

	mapping inMM::Timing::TimingExpressions2CCSL() : TimeModel::CCSLModel::ClockConstraintSystem {
	    theCCSLSpec := result;
	    name := self.name;
	    theMainBlock :=object TimeModel::CCSLModel::Block{
	    	name := "mainBlock";
	    };
	    subBlock += theMainBlock;
	    result.superBlock := theMainBlock;

		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib';
			alias := 'kernel';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib';
			alias := 'CCSL';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/resource/fr.inria.aoste.timmo2use.tadl2.examples/BrakeByWireOneWheel/tadl2.ccslLib';
			alias := 'tadl2';
			
		}; 
	
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};

		

		inM.rootObjects().allSubobjects()->including(self)[ Event ]->map tadlEvent2Clock();
		


		

		inM.rootObjects().allSubobjects()->including(self)[ TimeBase ]->map ref2Clock();
		


		

		inM.rootObjects().allSubobjects()->including(self)[ Dimension ]->map discretized2Clock();
		


		

		


		
		inM.rootObjects().allSubobjects()->including(self)[ ReactionConstraint ]->map reactionConstraintMax552reactionConstraintMax();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ ReactionConstraint ]->map reactionConstraintMin552reactionConstraintMin();
		
		

		


		
		inM.rootObjects().allSubobjects()->including(self)[ AgeConstraint ]->map AgeConstraintSemanticsMax712AgeConstraintSemanticsMax();
		
		

		


		
		inM.rootObjects().allSubobjects()->including(self)[ TimeBase ]->map periodicTB282periodicTB();
		
		

		


		
		inM.rootObjects().allSubobjects()->including(self)[ TimeBaseRelation ]->map TBRrelation582TBRrelation();
		
		

		


		
		inM.rootObjects().allSubobjects()->including(self)[ SynchronizationConstraint ]->map synchronisation552synchronisation();
		
		

		


		
		inM.rootObjects().allSubobjects()->including(self)[ EventChain ]->map eventChainCausality702eventChainCausality();
		
		

		


		
		inM.rootObjects().allSubobjects()->including(self)[ SporadicConstraint ]->map sporadicConstraintRelation432sporadicConstraintRelation();
		
		

		


		
		inM.rootObjects().allSubobjects()->including(self)[ PeriodicConstraint ]->map periodicConstraintRelation432periodicConstraintRelation();
		
		

		


		
		inM.rootObjects().allSubobjects()->including(self)[ DelayConstraint ]->map delayConstraintRelation452delayConstraintRelation();
		
	}





//create the expressions...
	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::ReactionConstraint::intermediate_chain2Expression(an1 : TimingExpressions::Event, an2 : TimingExpressions::Event, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_chain'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "SampledOn")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_tadlEvent']->first();
					_abstract := seqOfAbstractEntity[name = 'SampledOnSampledClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'SampledOn']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_tadlEvent']->first();
					_abstract := seqOfAbstractEntity[name = 'SampledOnSampledClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'SampledOn']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::ReactionConstraint::intermediate_chain2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : TimingExpressions::Event, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_chain'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "SampledOn")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
_abstract := seqOfExpressionDeclaration[name = 'SampledOn']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);									};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_tadlEvent']->first();
					
					_abstract := seqOfAbstractEntity[name = 'SampledOnSampledClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'SampledOn']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::ReactionConstraint::chain2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(TimingExpressions::Event) := self.scope.segment->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_chain2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_chain2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_chain2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::ReactionConstraint::deadline2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'_DelayFor_deadline';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "DelayFor")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.scope.stimulus.name+'_tadlEvent']->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForClockToDelay' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.maximum.oclAsType(SymbolicTimingExpression).variable.timeBase.name+'_ref']->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForClockForCounting' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self.maximum.oclAsType(SymbolicTimingExpression).variable.value.oclAsType(ValueTimingExpression).value -> map Real2Integer(self.name+self.maximum.oclAsType(SymbolicTimingExpression).variable.name+"_value")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForDelay' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::ReactionConstraint::intermediate_chainMin2Expression(an1 : TimingExpressions::Event, an2 : TimingExpressions::Event, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_chainMin'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "SampledOn")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_tadlEvent']->first();
					_abstract := seqOfAbstractEntity[name = 'SampledOnSampledClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'SampledOn']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_tadlEvent']->first();
					_abstract := seqOfAbstractEntity[name = 'SampledOnSampledClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'SampledOn']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::ReactionConstraint::intermediate_chainMin2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : TimingExpressions::Event, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_chainMin'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "SampledOn")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
_abstract := seqOfExpressionDeclaration[name = 'SampledOn']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);									};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_tadlEvent']->first();
					
					_abstract := seqOfAbstractEntity[name = 'SampledOnSampledClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'SampledOn']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::ReactionConstraint::chainMin2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(TimingExpressions::Event) := self.scope.segment->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_chainMin2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_chainMin2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_chainMin2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::ReactionConstraint::minTime2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'_DelayFor_minTime';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "DelayFor")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.scope.stimulus.name+'_tadlEvent']->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForClockToDelay' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.minimum.oclAsType(SymbolicTimingExpression).variable.timeBase.name+'_ref']->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForClockForCounting' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self.minimum.oclAsType(SymbolicTimingExpression).variable.value.oclAsType(ValueTimingExpression).value -> map Real2Integer(self.name+self.minimum.oclAsType(SymbolicTimingExpression).variable.name+"_value")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForDelay' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::AgeConstraint::intermediate_chain2Expression(an1 : TimingExpressions::Event, an2 : TimingExpressions::Event, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_chain'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "SampledOn")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_tadlEvent']->first();
					_abstract := seqOfAbstractEntity[name = 'SampledOnSampledClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'SampledOn']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_tadlEvent']->first();
					_abstract := seqOfAbstractEntity[name = 'SampledOnTrigger' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'SampledOn']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::AgeConstraint::intermediate_chain2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : TimingExpressions::Event, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_chain'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "SampledOn")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
_abstract := seqOfExpressionDeclaration[name = 'SampledOn']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);									};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_tadlEvent']->first();
					
_abstract := seqOfExpressionDeclaration[name = 'SampledOn']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);									
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::AgeConstraint::chain2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(TimingExpressions::Event) := self.scope.segment->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_chain2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_chain2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_chain2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::AgeConstraint::intermediate_overriding2Expression(an1 : TimingExpressions::Event, an2 : TimingExpressions::Event, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_overriding'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "AgeEventChainOverride")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_tadlEvent']->first();
					_abstract := seqOfAbstractEntity[name = 'AgeEventChainOverride_left' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'AgeEventChainOverride']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_tadlEvent']->first();
					_abstract := seqOfAbstractEntity[name = 'AgeEventChainOverride_right' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'AgeEventChainOverride']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::AgeConstraint::intermediate_overriding2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : TimingExpressions::Event, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_overriding'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "AgeEventChainOverride")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
_abstract := seqOfExpressionDeclaration[name = 'AgeEventChainOverride']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);									};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_tadlEvent']->first();
					
_abstract := seqOfExpressionDeclaration[name = 'AgeEventChainOverride']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);												};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::AgeConstraint::overriding2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(TimingExpressions::Event) := self.scope.segment->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_overriding2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_overriding2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_overriding2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::AgeConstraint::chainOrOverride2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'_Union_chainOrOverride';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map chain2Expression()->asSequence()->first();
					var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(size-1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map overriding2Expression()->asSequence()->first();
					var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(size-2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	mapping inMM::AgeConstraint::deadline2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'_DelayFor_deadline';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "DelayFor")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.scope.stimulus.name+'_tadlEvent']->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForClockToDelay' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.maximum.oclAsType(SymbolicTimingExpression).variable.timeBase.name+'_ref']->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForClockForCounting' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self.maximum.oclAsType(SymbolicTimingExpression).variable.value.oclAsType(ValueTimingExpression).value -> map Real2Integer(self.name+self.maximum.oclAsType(SymbolicTimingExpression).variable.name+"_value")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForDelay' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	mapping inMM::TimeBase::periodicClockTB2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'_Periodic_periodicClockTB';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Periodic")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.type.name+'_discretized']->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicBaseClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'Periodic']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := (self.precisionFactor * self.precisionUnit.factor) -> map Real2Integer(self.name+self.precisionUnit.name+"_factor")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicPeriod' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'Periodic']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := 0 -> map Real2Integer(self.name+self.name+"_0")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicOffset' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'Periodic']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	mapping inMM::TimeBaseRelation::leftRef2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'_Periodic_leftRef';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Periodic")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.left.oclAsType(ValueTimingExpression).timeBase.name+'_ref']->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicBaseClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'Periodic']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self.left.oclAsType(ValueTimingExpression).value -> map Real2Integer(self.name+"_value")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicPeriod' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'Periodic']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := 0 -> map Real2Integer(self.name+self.name+"_0")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicOffset' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'Periodic']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	mapping inMM::TimeBaseRelation::rightRef2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'_Periodic_rightRef';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Periodic")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.right.oclAsType(VariableTimingExpression).timeBase.name+'_ref']->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicBaseClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'Periodic']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self.right.oclAsType(ValueTimingExpression).value -> map Real2Integer(self.name+"_value")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicPeriod' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'Periodic']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := 0 -> map Real2Integer(self.name+self.name+"_0")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicOffset' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'Periodic']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::SynchronizationConstraint::intermediate_infSync2Expression(an1 : TimingExpressions::Event, an2 : TimingExpressions::Event, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_infSync'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Inf")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_tadlEvent']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Inf']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Inf).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_tadlEvent']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Inf']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Inf).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::SynchronizationConstraint::intermediate_infSync2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : TimingExpressions::Event, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_infSync'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Inf")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Inf']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Inf).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_tadlEvent']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Inf']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Inf).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::SynchronizationConstraint::infSync2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(TimingExpressions::Event) := self.events->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_infSync2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_infSync2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_infSync2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::SynchronizationConstraint::intermediate_supSync2Expression(an1 : TimingExpressions::Event, an2 : TimingExpressions::Event, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_supSync'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Sup")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_tadlEvent']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_tadlEvent']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::SynchronizationConstraint::intermediate_supSync2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : TimingExpressions::Event, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_supSync'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Sup")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_tadlEvent']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::SynchronizationConstraint::supSync2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(TimingExpressions::Event) := self.events->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_supSync2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_supSync2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_supSync2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::SynchronizationConstraint::delayedInf2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'_DelayFor_delayedInf';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "DelayFor")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map infSync2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForClockToDelay' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.tolerance.oclAsType(SymbolicTimingExpression).variable.timeBase.name+'_ref']->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForClockForCounting' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self.tolerance.oclAsType(SymbolicTimingExpression).variable.value.oclAsType(ValueTimingExpression).value -> map Real2Integer(self.name+self.tolerance.oclAsType(SymbolicTimingExpression).variable.name+"_value")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForDelay' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	mapping inMM::SporadicConstraint::sporadicMin2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'_Periodic_sporadicMin';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Periodic")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.lower.oclAsType(SymbolicTimingExpression).variable.oclAsType(VariableTimingExpression).timeBase.name+'_ref']->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicBaseClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'Periodic']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self.lower.oclAsType(SymbolicTimingExpression).variable.value.oclAsType(ValueTimingExpression).value -> map Real2Integer(self.name+self.lower.oclAsType(SymbolicTimingExpression).variable.name+"_value")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicPeriod' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'Periodic']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := 0 -> map Real2Integer(self.name+self.name+"_0")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicOffset' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'Periodic']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	mapping inMM::PeriodicConstraint::periodicClock2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'_Periodic_periodicClock';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Periodic")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.period.oclAsType(SymbolicTimingExpression).variable.oclAsType(VariableTimingExpression).timeBase.name+'_ref']->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicBaseClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'Periodic']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self.period.oclAsType(SymbolicTimingExpression).variable.value.oclAsType(ValueTimingExpression).value -> map Real2Integer(self.name+self.period.oclAsType(SymbolicTimingExpression).variable.name+"_value")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicPeriod' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'Periodic']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := 0 -> map Real2Integer(self.name+self.name+"_0")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicOffset' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'Periodic']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	mapping inMM::DelayConstraint::delayedClock2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'_DelayFor_delayedClock';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "DelayFor")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.source.name+'_tadlEvent']->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForClockToDelay' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.upper.oclAsType(SymbolicTimingExpression).variable.oclAsType(VariableTimingExpression).timeBase.name+'_ref']->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForClockForCounting' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self.upper.oclAsType(SymbolicTimingExpression).variable.value.oclAsType(ValueTimingExpression).value -> map Real2Integer(self.name+self.upper.oclAsType(SymbolicTimingExpression).variable.name+"_value")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForDelay' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}




	 	mapping inMM::Event::tadlEvent2Clock() :TimeModel::Clock 
		{
			name:= self.name+'_tadlEvent';
			
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.triggerableElements->first().oclAsType(EObject);
				name := 'evt_'+self.name+'_tadlEvent';
				kind := TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM::TimeBase::ref2Clock() :TimeModel::Clock 
		{
			name:= self.name+'_ref';
			
			tickingEvent := object TimeModel::Event{
				name := 'evt_'+self.name+'_ref';
				kind := TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM::Dimension::discretized2Clock() :TimeModel::Clock 
		{
			name:= self.name+'_discretized';
			
			tickingEvent := object TimeModel::Event{
				name := 'evt_'+self.name+'_discretized';
				kind := TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		

//relation stuff		
	
		mapping inMM::ReactionConstraint::reactionConstraintMax552reactionConstraintMax(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Precedes_reactionConstraintMax";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map chain2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map deadline2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::ReactionConstraint::reactionConstraintMin552reactionConstraintMin(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Precedes_reactionConstraintMin";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map minTime2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map chainMin2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM::AgeConstraint::AgeConstraintSemanticsMax712AgeConstraintSemanticsMax(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Precedes_AgeConstraintSemanticsMax";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map chainOrOverride2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map deadline2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM::TimeBase::periodicTB282periodicTB(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Coincides_periodicTB";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_ref']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map periodicClockTB2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM::TimeBaseRelation::TBRrelation582TBRrelation(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Coincides_TBRrelation";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map leftRef2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map rightRef2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM::SynchronizationConstraint::synchronisation552synchronisation(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Precedes_synchronisation";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map supSync2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map delayedInf2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	

//Create an intermediate relation
	mapping inMM::EventChain::intermediate_eventChainCausality702eventChainCausality(an1 : TimingExpressions::Event, an2 : TimingExpressions::Event, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := self.name+'intermediate_eventChainCausality'+nbi.toString()+"_"+nbj.toString();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Causes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_tadlEvent']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::NonStrictPrecedence).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_tadlEvent']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::NonStrictPrecedence).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM::EventChain::eventChainCausality702eventChainCausality()
			when { --if not used in a reaction constraint 
         ((not self.container().oclAsType(Timing).constraints->select(te | te.oclIsKindOf(ReactionConstraint))
         .oclAsType(ReactionConstraint)->exists(rc | rc.scope = self))
          and  
          (not self.container().oclAsType(Timing).constraints->select(te | te.oclIsKindOf(AgeConstraint))
         .oclAsType(AgeConstraint)->exists(rc | rc.scope = self))
         ) }
	{
		init{
			var sources : Sequence(TimingExpressions::Event) := self.segment->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_eventChainCausality702eventChainCausality(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		

//relation stuff		
	
		mapping inMM::SporadicConstraint::sporadicConstraintRelation432sporadicConstraintRelation(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Precedes_sporadicConstraintRelation";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map sporadicMin2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.event.name+'_tadlEvent']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM::PeriodicConstraint::periodicConstraintRelation432periodicConstraintRelation(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Coincides_periodicConstraintRelation";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map periodicClock2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.event.name+'_tadlEvent']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM::DelayConstraint::delayConstraintRelation452delayConstraintRelation(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Coincides_delayConstraintRelation";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map delayedClock2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.target.name+'_tadlEvent']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		
		theMainBlock.relations += result;
		}
		

