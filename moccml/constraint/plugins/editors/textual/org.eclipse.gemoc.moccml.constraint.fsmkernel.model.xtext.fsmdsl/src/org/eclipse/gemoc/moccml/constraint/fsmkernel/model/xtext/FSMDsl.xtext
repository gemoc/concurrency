// automatically generated by Xtext
//And hand modified!
grammar org.eclipse.gemoc.moccml.constraint.fsmkernel.model.xtext.FSMDsl with fr.inria.aoste.timesquare.ccslkernel.library.xtext.CCSLLibrary

import "http://org.eclipse.gemoc.moccml.fsmmodel/1.0" as fsmmodel  
import "http://org.eclipse.gemoc.mocc.fsmmodel/editionextension/1.0" as extension
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://fr.inria.aoste.timemodel" as timemodel  
import "http://fr.inria.aoste.timemodel.primitivetypes" as PrimitivesTypeValue
import "http://fr.inria.aoste.timemodel.classicalexpression" as ClassicalExpression
import "http://fr.inria.aoste.timemodel.ccslmodel.clockexpressionandrelation" as ClockExpressionAndRelation
import "http://fr.inria.aoste.timemodel.basicTypes" as BasicType
 
StateMachineDefinition returns fsmmodel::StateMachineDefinition: 
	{fsmmodel::StateMachineDefinition}
	'AutomataDefinition' name=EString
	'{'
		(declarationBlock=DeclarationBlock)? 
		('init' ':' initialStates+= [fsmmodel::State|EString]) ( "," initialStates+=[fsmmodel::State|EString])*
		('finals' ':' finalStates+=[fsmmodel::State|EString] ( "," finalStates+=[fsmmodel::State|EString])* )?
		((states+=State)|
		(transitions+=Transition))+
		
    '}'; 
	
DeclarationBlock returns fsmmodel::DeclarationBlock: 
   {fsmmodel::DeclarationBlock}
    'variables' '{'(concreteEntities+=ConcreteEntity)* (classicalExpressions+=BooleanExpression)*'}'
; 

Transition returns fsmmodel::Transition:
	{fsmmodel::Transition}
	'from' source=[fsmmodel::State|EString] 'to' target=[fsmmodel::State|EString]':' (name = EString '->')?'('
		('when' trigger=Trigger)?
		('if' guard=Guard)?
		('do' (actions+=Action))*
	')';

Action returns fsmmodel::AbstractAction:
	IntegerAssignement	| IntegerAssignementBlock
;

IntegerAssignementBlock returns extension::IntegerAssignementBlock:
	{extension::IntegerAssignementBlock}
	'#ref'name=EString
	'{'
		actions+=IntegerAssignement ( "," actions+=IntegerAssignement)*
	'}'
;

State returns fsmmodel::State:
	{fsmmodel::State} 
	'State' name=EString '('
	('in' ':' inputTransitions+=[fsmmodel::Transition] ( "," inputTransitions+=[fsmmodel::Transition])* )?
	('out' ':' outputTransitions+=[fsmmodel::Transition] ( "," outputTransitions+=[fsmmodel::Transition])* )?
	')';

	
Guard returns fsmmodel::Guard:
	{fsmmodel::Guard}
	(value=BooleanExpression)
	;
	
Trigger returns fsmmodel::Trigger:
	{fsmmodel::Trigger}
	'Trigger'
	'{'
		('trueTriggers' '(' trueTriggers+=[ClockExpressionAndRelation::BindableEntity|EString] ( "," trueTriggers+=[ClockExpressionAndRelation::BindableEntity|EString])* ')' )?
		('falseTriggers' '(' falseTriggers+=[ClockExpressionAndRelation::BindableEntity|EString] ( "," falseTriggers+=[ClockExpressionAndRelation::BindableEntity|EString])* ')' )?
	'}';
	 
BinaryIntegerExpression returns ClassicalExpression::BinaryIntegerExpression:
	IntPlus | IntMinus | IntMultiply | IntDivide | IntegerAssignement|IntSelfPlusAssign|IntSelfMinusAssign|IntSelfMultAssign|IntSelfDivAssign;

IntSelfPlusAssign returns extension::IntSelfPlusAssignement:
	{extension::IntSelfPlusAssignement}
	('#ref'name=EString '=')? leftValue=IntegerRef '+=' rightValue=IntegerExpression
;

IntSelfMinusAssign returns extension::IntSelfMinusAssignement:
	{extension::IntSelfMinusAssignement}
	('#ref'name=EString '=')? leftValue=IntegerRef '-=' rightValue=IntegerExpression
;

IntSelfMultAssign returns extension::IntSelfMultiplyAssignement:
	{extension::IntSelfMultiplyAssignement}
	('#ref'name=EString '=')? leftValue=IntegerRef '*=' rightValue=IntegerExpression
;

IntSelfDivAssign returns extension::IntSelfDivideAssignement:
	{extension::IntSelfDivideAssignement}
	('#ref'name=EString '=')? leftValue=IntegerRef '/=' rightValue=IntegerExpression
;
	
IntegerAssignement returns fsmmodel::IntegerAssignement:
	{fsmmodel::IntegerAssignement}
	('#ref'name=EString ':')? leftValue=IntegerRef '=' rightValue=IntegerExpression //';'//'Assign'  '('leftValue=IntegerRef ',' rightValue=IntegerExpression ')'
;

@Override
IntegerExpression returns ClassicalExpression::IntegerExpression:
	BinaryIntegerExpression | UnaryIntegerExpression |IntegerRef | SeqGetHead |IntegerVariableRef;

@Override
IntegerVariableRef returns ClassicalExpression::IntegerVariableRef:
	(referencedVar=[ClockExpressionAndRelation::AbstractEntity|EString]".value")
	|
	("get("referencedVar=[ClockExpressionAndRelation::AbstractEntity|EString]")") |
	('IntegerVariableRef' (name=ID)? '['referencedVar=[ClockExpressionAndRelation::AbstractEntity|EString]']')
	;
	

UnaryIntegerExpression returns ClassicalExpression::UnaryIntegerExpression: 
 UnaryIntPlus | UnaryIntMinus;

@Override
IntEqual returns ClassicalExpression::IntEqual:
	('('('#ref' name=String0 ':')? leftValue=IntegerExpression '==' rightValue=IntegerExpression')')|
	('('('#ref' name=String0 '::'type=[BasicType::Type|EString] ':')? leftValue=IntegerExpression '==' rightValue=IntegerExpression')');

@Override    
BooleanRef returns ClassicalExpression::BooleanRef:
	(referencedBool=[BasicType::BooleanElement|EString]) | 'b['referencedBool=[BasicType::BooleanElement|EString]']'|'b#ref'name=ID'['referencedBool=[BasicType::BooleanElement|EString]']';

@Override
IntegerRef returns ClassicalExpression::IntegerRef:
	(integerElem=[BasicType::IntegerElement|EString]) | 'i.'(integerElem=[BasicType::IntegerElement|EString])|('i#ref'name=ID'['integerElem=[BasicType::IntegerElement|EString]']');


@Override
UnaryIntPlus returns ClassicalExpression::UnaryIntPlus:
	('+' 
	'{'
		'value' value=[BasicType::IntegerElement|EString]
		'operand' operand=IntegerExpression
	'}')|
	('(+' ('#ref' name=String0 (':'type=[BasicType::Type|EString])?)?
	'{'
		'value' value=[BasicType::IntegerElement|EString]
		'operand' operand=IntegerExpression
	'})');
	
@Override
UnaryIntMinus returns ClassicalExpression::UnaryIntMinus:
	('-' 
	'{'
		'value' value=[BasicType::IntegerElement|EString]
		'operand' operand=IntegerExpression
	'}')|
	('(-' ('#ref' name=String0 (':'type=[BasicType::Type|EString])?)?
	'{'
		'value' value=[BasicType::IntegerElement|EString]
		'operand' operand=IntegerExpression
	'})');

@Override
IntPlus returns ClassicalExpression::IntPlus:
		('('('#ref' name=String0 ':')? leftValue=IntegerExpression '+' rightValue=IntegerExpression')')|
	('('('#ref' name=String0 '::'type=[BasicType::Type|EString] ':')? leftValue=IntegerExpression '+' rightValue=IntegerExpression')');

@Override
IntMinus returns ClassicalExpression::IntMinus:
		('('('#ref' name=String0 ':')? leftValue=IntegerExpression '-' rightValue=IntegerExpression')')|
	('('('#ref' name=String0 '::'type=[BasicType::Type|EString] ':')? leftValue=IntegerExpression '-' rightValue=IntegerExpression')');

@Override
IntMultiply returns ClassicalExpression::IntMultiply:
		('('('#ref' name=String0 ':')? leftValue=IntegerExpression '*' rightValue=IntegerExpression')')|
	('('('#ref' name=String0 '::'type=[BasicType::Type|EString] ':')? leftValue=IntegerExpression '*' rightValue=IntegerExpression')');

@Override
IntDivide returns ClassicalExpression::IntDivide:
		('('('#ref' name=String0 ':')? leftValue=IntegerExpression '/' rightValue=IntegerExpression')')|
	('('('#ref' name=String0 '::'type=[BasicType::Type|EString] ':')? leftValue=IntegerExpression '/' rightValue=IntegerExpression')');

@Override
Not returns ClassicalExpression::Not:
	('!' operand=BooleanExpression)|
	('!('('#ref' name=String0 (':'type=[BasicType::Type|EString])?)?
		operand=BooleanExpression)')';

@Override
And returns ClassicalExpression::And:
	'and' '(' ('#ref' name=String0 (':'type=[BasicType::Type|EString])?)?
	leftValue=BooleanExpression	'^' rightValue=BooleanExpression')';

@Override
Or returns ClassicalExpression::Or:
	'or' '(' ('#ref' name=String0 (':'type=[BasicType::Type|EString])?)?
	leftValue=BooleanExpression	'v' rightValue=BooleanExpression')';
@Override
Xor returns ClassicalExpression::Xor:
	'xor' '(' ('#ref' name=String0 (':'type=[BasicType::Type|EString])?)?
	leftValue=BooleanExpression	'v_' rightValue=BooleanExpression')';

@Override
IntInf returns ClassicalExpression::IntInf:
	('('('#ref' name=String0 ':')? leftValue=IntegerExpression '<' rightValue=IntegerExpression')')|
	('('('#ref' name=String0 '::'type=[BasicType::Type|EString] ':')? leftValue=IntegerExpression '<' rightValue=IntegerExpression')');

@Override
IntSup returns ClassicalExpression::IntSup:
	('('('#ref' name=String0 ':')? leftValue=IntegerExpression '>' rightValue=IntegerExpression')')|
	('('('#ref' name=String0 '::'type=[BasicType::Type|EString] ':')? leftValue=IntegerExpression '>' rightValue=IntegerExpression')');

@Override
SeqIsEmpty returns ClassicalExpression::SeqIsEmpty:
	'SeqIsEmpty' ('#ref' name=String0 (':'type=[BasicType::Type|EString])?)?
	'('
		operand=SeqExpression
	')';

@Override
SeqGetTail returns ClassicalExpression::SeqGetTail:
	'Seq->Tail' ('#ref' name=String0 (':'type=[BasicType::Type|EString])?)?
	'('
		operand=SeqExpression
	')';

@Override
SeqGetHead returns ClassicalExpression::SeqGetHead:
	'Seq->Head' ('#ref' name=String0 (':'type=[BasicType::Type|EString])?)?
	'('
		operand=SeqExpression
	')';

@Override
SeqDecr returns ClassicalExpression::SeqDecr:
	'Seq--' ('#ref'name=ID ':')? '(' operand=SeqExpression')';

@Override
SeqSched returns ClassicalExpression::SeqSched:
	'Seq++' ('#ref'name=ID ':')? '(' operand=SeqExpression ','integerExpr=IntegerExpression ')';

@Override
BooleanExpression returns ClassicalExpression::BooleanExpression:
	BooleanRef | Not | And | Or | Xor | IntEqual | IntInf | IntSup | SeqIsEmpty | BooleanVariableRef|IntInfEqual|IntSupEqual;


IntSupEqual returns extension::IntSupEqual:
	('('('#ref' name=String0 ':')? leftValue=IntegerExpression '>=' rightValue=IntegerExpression')')|
	('('('#ref' name=String0 '::'type=[BasicType::Type|EString] ':')? leftValue=IntegerExpression '>=' rightValue=IntegerExpression')');


IntInfEqual returns extension::IntInfEqual:
	('('('#ref' name=String0 ':')? leftValue=IntegerExpression '<=' rightValue=IntegerExpression')')|
	('('('#ref' name=String0 '::'type=[BasicType::Type|EString] ':')? leftValue=IntegerExpression '<=' rightValue=IntegerExpression')');



@Override
ClassicalExpression0 returns ClassicalExpression::ClassicalExpression:
	BooleanExpression | IntegerExpression | SeqExpression; 
	
