/*
* generated by Xtext
*/
package org.gemoc.gel.services;

import java.util.List;

import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;
import org.gemoc.gexpressions.xtext.services.GExpressionsGrammarAccess;

import com.google.inject.Inject;
import com.google.inject.Singleton;

@Singleton
public class GELGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class DomainSpecificEventsSpecificationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DomainSpecificEventsSpecification");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDomainSpecificEventsSpecificationAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cImportsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportsImportStatementParserRuleCall_1_0 = (RuleCall)cImportsAssignment_1.eContents().get(0);
		private final Assignment cEventsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEventsDomainSpecificEventParserRuleCall_2_0 = (RuleCall)cEventsAssignment_2.eContents().get(0);
		
		////import "http://www.gemoc.org/gel/SimpleOCL" as simpleocl
		////-----------------------------------------------------------------------------
		//// Main stuff
		////-----------------------------------------------------------------------------
		//DomainSpecificEventsSpecification returns gel::DomainSpecificEventsSpecification:
		//	{gel::DomainSpecificEventsSpecification} imports+=ImportStatement* events+=DomainSpecificEvent*;
		public ParserRule getRule() { return rule; }

		//{gel::DomainSpecificEventsSpecification} imports+=ImportStatement* events+=DomainSpecificEvent*
		public Group getGroup() { return cGroup; }

		//{gel::DomainSpecificEventsSpecification}
		public Action getDomainSpecificEventsSpecificationAction_0() { return cDomainSpecificEventsSpecificationAction_0; }

		//imports+=ImportStatement*
		public Assignment getImportsAssignment_1() { return cImportsAssignment_1; }

		//ImportStatement
		public RuleCall getImportsImportStatementParserRuleCall_1_0() { return cImportsImportStatementParserRuleCall_1_0; }

		//events+=DomainSpecificEvent*
		public Assignment getEventsAssignment_2() { return cEventsAssignment_2; }

		//DomainSpecificEvent
		public RuleCall getEventsDomainSpecificEventParserRuleCall_2_0() { return cEventsDomainSpecificEventParserRuleCall_2_0; }
	}

	public class ImportStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ImportStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImportURIAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportURISTRINGTerminalRuleCall_1_0 = (RuleCall)cImportURIAssignment_1.eContents().get(0);
		
		//ImportStatement returns gel::ImportStatement:
		//	"import" importURI= / *('as' alias=ID)?* / STRING;
		public ParserRule getRule() { return rule; }

		//"import" importURI= / *('as' alias=ID)?* / STRING
		public Group getGroup() { return cGroup; }

		//"import"
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }

		//importURI= / *('as' alias=ID)?* / STRING
		public Assignment getImportURIAssignment_1() { return cImportURIAssignment_1; }

		/// *('as' alias=ID)?* / STRING
		public RuleCall getImportURISTRINGTerminalRuleCall_1_0() { return cImportURISTRINGTerminalRuleCall_1_0; }
	}

	public class DomainSpecificEventElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DomainSpecificEvent");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAtomicDomainSpecificEventParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCompositeDomainSpecificEventParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//DomainSpecificEvent returns gel::DomainSpecificEvent:
		//	AtomicDomainSpecificEvent | CompositeDomainSpecificEvent;
		public ParserRule getRule() { return rule; }

		//AtomicDomainSpecificEvent | CompositeDomainSpecificEvent
		public Alternatives getAlternatives() { return cAlternatives; }

		//AtomicDomainSpecificEvent
		public RuleCall getAtomicDomainSpecificEventParserRuleCall_0() { return cAtomicDomainSpecificEventParserRuleCall_0; }

		//CompositeDomainSpecificEvent
		public RuleCall getCompositeDomainSpecificEventParserRuleCall_1() { return cCompositeDomainSpecificEventParserRuleCall_1; }
	}

	public class AtomicDomainSpecificEventElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtomicDomainSpecificEvent");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAtomicDomainSpecificEventAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cVisibilityAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVisibilityVisibilityEnumRuleCall_1_0 = (RuleCall)cVisibilityAssignment_1.eContents().get(0);
		private final Keyword cDSEKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cColonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cUponKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cUponMoccEventAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cUponMoccEventMoccEventParserRuleCall_6_0 = (RuleCall)cUponMoccEventAssignment_6.eContents().get(0);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Assignment cExecutionKindAssignment_7_0 = (Assignment)cGroup_7.eContents().get(0);
		private final RuleCall cExecutionKindExecutionKindEnumRuleCall_7_0_0 = (RuleCall)cExecutionKindAssignment_7_0.eContents().get(0);
		private final Assignment cExecutionFunctionAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cExecutionFunctionExecutionFunctionParserRuleCall_7_1_0 = (RuleCall)cExecutionFunctionAssignment_7_1.eContents().get(0);
		private final Group cGroup_7_2 = (Group)cGroup_7.eContents().get(2);
		private final Keyword cFeedbackKeyword_7_2_0 = (Keyword)cGroup_7_2.eContents().get(0);
		private final Keyword cColonKeyword_7_2_1 = (Keyword)cGroup_7_2.eContents().get(1);
		private final Assignment cFeedbackPolicyAssignment_7_2_2 = (Assignment)cGroup_7_2.eContents().get(2);
		private final RuleCall cFeedbackPolicyFeedbackPolicyParserRuleCall_7_2_2_0 = (RuleCall)cFeedbackPolicyAssignment_7_2_2.eContents().get(0);
		private final Keyword cEndKeyword_7_2_3 = (Keyword)cGroup_7_2.eContents().get(3);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cRaisesKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cRaisedMoccEventAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cRaisedMoccEventMoccEventParserRuleCall_8_1_0 = (RuleCall)cRaisedMoccEventAssignment_8_1.eContents().get(0);
		private final Keyword cEndKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//AtomicDomainSpecificEvent returns gel::DomainSpecificEvent:
		//	{gel::AtomicDomainSpecificEvent} visibility=Visibility? "DSE" name=ID ":" "upon" uponMoccEvent=MoccEvent
		//	(executionKind=ExecutionKind executionFunction=ExecutionFunction ("feedback" ":" feedbackPolicy=FeedbackPolicy
		//	"end")?)? ("raises" raisedMoccEvent=MoccEvent)? "end";
		public ParserRule getRule() { return rule; }

		//{gel::AtomicDomainSpecificEvent} visibility=Visibility? "DSE" name=ID ":" "upon" uponMoccEvent=MoccEvent
		//(executionKind=ExecutionKind executionFunction=ExecutionFunction ("feedback" ":" feedbackPolicy=FeedbackPolicy
		//"end")?)? ("raises" raisedMoccEvent=MoccEvent)? "end"
		public Group getGroup() { return cGroup; }

		//{gel::AtomicDomainSpecificEvent}
		public Action getAtomicDomainSpecificEventAction_0() { return cAtomicDomainSpecificEventAction_0; }

		//visibility=Visibility?
		public Assignment getVisibilityAssignment_1() { return cVisibilityAssignment_1; }

		//Visibility
		public RuleCall getVisibilityVisibilityEnumRuleCall_1_0() { return cVisibilityVisibilityEnumRuleCall_1_0; }

		//"DSE"
		public Keyword getDSEKeyword_2() { return cDSEKeyword_2; }

		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }

		//":"
		public Keyword getColonKeyword_4() { return cColonKeyword_4; }

		//"upon"
		public Keyword getUponKeyword_5() { return cUponKeyword_5; }

		//uponMoccEvent=MoccEvent
		public Assignment getUponMoccEventAssignment_6() { return cUponMoccEventAssignment_6; }

		//MoccEvent
		public RuleCall getUponMoccEventMoccEventParserRuleCall_6_0() { return cUponMoccEventMoccEventParserRuleCall_6_0; }

		//(executionKind=ExecutionKind executionFunction=ExecutionFunction ("feedback" ":" feedbackPolicy=FeedbackPolicy "end")?)?
		public Group getGroup_7() { return cGroup_7; }

		//executionKind=ExecutionKind
		public Assignment getExecutionKindAssignment_7_0() { return cExecutionKindAssignment_7_0; }

		//ExecutionKind
		public RuleCall getExecutionKindExecutionKindEnumRuleCall_7_0_0() { return cExecutionKindExecutionKindEnumRuleCall_7_0_0; }

		//executionFunction=ExecutionFunction
		public Assignment getExecutionFunctionAssignment_7_1() { return cExecutionFunctionAssignment_7_1; }

		//ExecutionFunction
		public RuleCall getExecutionFunctionExecutionFunctionParserRuleCall_7_1_0() { return cExecutionFunctionExecutionFunctionParserRuleCall_7_1_0; }

		//("feedback" ":" feedbackPolicy=FeedbackPolicy "end")?
		public Group getGroup_7_2() { return cGroup_7_2; }

		//"feedback"
		public Keyword getFeedbackKeyword_7_2_0() { return cFeedbackKeyword_7_2_0; }

		//":"
		public Keyword getColonKeyword_7_2_1() { return cColonKeyword_7_2_1; }

		//feedbackPolicy=FeedbackPolicy
		public Assignment getFeedbackPolicyAssignment_7_2_2() { return cFeedbackPolicyAssignment_7_2_2; }

		//FeedbackPolicy
		public RuleCall getFeedbackPolicyFeedbackPolicyParserRuleCall_7_2_2_0() { return cFeedbackPolicyFeedbackPolicyParserRuleCall_7_2_2_0; }

		//"end"
		public Keyword getEndKeyword_7_2_3() { return cEndKeyword_7_2_3; }

		//("raises" raisedMoccEvent=MoccEvent)?
		public Group getGroup_8() { return cGroup_8; }

		//"raises"
		public Keyword getRaisesKeyword_8_0() { return cRaisesKeyword_8_0; }

		//raisedMoccEvent=MoccEvent
		public Assignment getRaisedMoccEventAssignment_8_1() { return cRaisedMoccEventAssignment_8_1; }

		//MoccEvent
		public RuleCall getRaisedMoccEventMoccEventParserRuleCall_8_1_0() { return cRaisedMoccEventMoccEventParserRuleCall_8_1_0; }

		//"end"
		public Keyword getEndKeyword_9() { return cEndKeyword_9; }
	}

	public class CompositeDomainSpecificEventElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompositeDomainSpecificEvent");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCompositeDomainSpecificEventAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cVisibilityAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVisibilityVisibilityEnumRuleCall_1_0 = (RuleCall)cVisibilityAssignment_1.eContents().get(0);
		private final Keyword cCompositeKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cColonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cUnfoldingStrategyAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cUnfoldingStrategyUnfoldingStrategyParserRuleCall_5_0 = (RuleCall)cUnfoldingStrategyAssignment_5.eContents().get(0);
		private final Assignment cBodyAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cBodyDomainSpecificEventsPatternParserRuleCall_6_0 = (RuleCall)cBodyAssignment_6.eContents().get(0);
		private final Keyword cEndKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//// End
		////-----------------------------------------------------------------------------
		//// Composite DSE stuff
		////-----------------------------------------------------------------------------
		//CompositeDomainSpecificEvent returns gel::DomainSpecificEvent:
		//	{gel::CompositeDomainSpecificEvent} visibility=Visibility? "Composite" name=ID ":"
		//	unfoldingStrategy=UnfoldingStrategy? body=DomainSpecificEventsPattern "end";
		public ParserRule getRule() { return rule; }

		//{gel::CompositeDomainSpecificEvent} visibility=Visibility? "Composite" name=ID ":" unfoldingStrategy=UnfoldingStrategy?
		//body=DomainSpecificEventsPattern "end"
		public Group getGroup() { return cGroup; }

		//{gel::CompositeDomainSpecificEvent}
		public Action getCompositeDomainSpecificEventAction_0() { return cCompositeDomainSpecificEventAction_0; }

		//visibility=Visibility?
		public Assignment getVisibilityAssignment_1() { return cVisibilityAssignment_1; }

		//Visibility
		public RuleCall getVisibilityVisibilityEnumRuleCall_1_0() { return cVisibilityVisibilityEnumRuleCall_1_0; }

		//"Composite"
		public Keyword getCompositeKeyword_2() { return cCompositeKeyword_2; }

		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }

		//":"
		public Keyword getColonKeyword_4() { return cColonKeyword_4; }

		//unfoldingStrategy=UnfoldingStrategy?
		public Assignment getUnfoldingStrategyAssignment_5() { return cUnfoldingStrategyAssignment_5; }

		//UnfoldingStrategy
		public RuleCall getUnfoldingStrategyUnfoldingStrategyParserRuleCall_5_0() { return cUnfoldingStrategyUnfoldingStrategyParserRuleCall_5_0; }

		//body=DomainSpecificEventsPattern
		public Assignment getBodyAssignment_6() { return cBodyAssignment_6; }

		//DomainSpecificEventsPattern
		public RuleCall getBodyDomainSpecificEventsPatternParserRuleCall_6_0() { return cBodyDomainSpecificEventsPatternParserRuleCall_6_0; }

		//"end"
		public Keyword getEndKeyword_7() { return cEndKeyword_7; }
	}

	public class UnfoldingStrategyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnfoldingStrategy");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUnfoldingStrategyAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cForallKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cLocalVariablesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLocalVariablesLocalVariableParserRuleCall_3_0 = (RuleCall)cLocalVariablesAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cWhereKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cLeftCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cInstantiationPredicatesAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cInstantiationPredicatesInstantiationPredicateParserRuleCall_7_0 = (RuleCall)cInstantiationPredicatesAssignment_7.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//UnfoldingStrategy returns gel::UnfoldingStrategy:
		//	{gel::UnfoldingStrategy} "forall" "{" localVariables+=LocalVariable+ "}" "where" "{"
		//	instantiationPredicates+=InstantiationPredicate+ "}";
		public ParserRule getRule() { return rule; }

		//{gel::UnfoldingStrategy} "forall" "{" localVariables+=LocalVariable+ "}" "where" "{"
		//instantiationPredicates+=InstantiationPredicate+ "}"
		public Group getGroup() { return cGroup; }

		//{gel::UnfoldingStrategy}
		public Action getUnfoldingStrategyAction_0() { return cUnfoldingStrategyAction_0; }

		//"forall"
		public Keyword getForallKeyword_1() { return cForallKeyword_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//localVariables+=LocalVariable+
		public Assignment getLocalVariablesAssignment_3() { return cLocalVariablesAssignment_3; }

		//LocalVariable
		public RuleCall getLocalVariablesLocalVariableParserRuleCall_3_0() { return cLocalVariablesLocalVariableParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }

		//"where"
		public Keyword getWhereKeyword_5() { return cWhereKeyword_5; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_6() { return cLeftCurlyBracketKeyword_6; }

		//instantiationPredicates+=InstantiationPredicate+
		public Assignment getInstantiationPredicatesAssignment_7() { return cInstantiationPredicatesAssignment_7; }

		//InstantiationPredicate
		public RuleCall getInstantiationPredicatesInstantiationPredicateParserRuleCall_7_0() { return cInstantiationPredicatesInstantiationPredicateParserRuleCall_7_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_8() { return cRightCurlyBracketKeyword_8; }
	}

	public class LocalVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LocalVariable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLocalVariableAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cTypeEClassifierCrossReference_3_0 = (CrossReference)cTypeAssignment_3.eContents().get(0);
		private final RuleCall cTypeEClassifierQualifiedNameParserRuleCall_3_0_1 = (RuleCall)cTypeEClassifierCrossReference_3_0.eContents().get(1);
		
		//LocalVariable returns gel::LocalVariable:
		//	{gel::LocalVariable} name=ID ":" type=[ecore::EClassifier|QualifiedName];
		public ParserRule getRule() { return rule; }

		//{gel::LocalVariable} name=ID ":" type=[ecore::EClassifier|QualifiedName]
		public Group getGroup() { return cGroup; }

		//{gel::LocalVariable}
		public Action getLocalVariableAction_0() { return cLocalVariableAction_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=[ecore::EClassifier|QualifiedName]
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//[ecore::EClassifier|QualifiedName]
		public CrossReference getTypeEClassifierCrossReference_3_0() { return cTypeEClassifierCrossReference_3_0; }

		//QualifiedName
		public RuleCall getTypeEClassifierQualifiedNameParserRuleCall_3_0_1() { return cTypeEClassifierQualifiedNameParserRuleCall_3_0_1; }
	}

	public class InstantiationPredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InstantiationPredicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cInstantiationPredicateAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBodyGExpressionParserRuleCall_1_0 = (RuleCall)cBodyAssignment_1.eContents().get(0);
		
		//InstantiationPredicate returns gel::InstantiationPredicate:
		//	{gel::InstantiationPredicate} body=GExpression;
		public ParserRule getRule() { return rule; }

		//{gel::InstantiationPredicate} body=GExpression
		public Group getGroup() { return cGroup; }

		//{gel::InstantiationPredicate}
		public Action getInstantiationPredicateAction_0() { return cInstantiationPredicateAction_0; }

		//body=GExpression
		public Assignment getBodyAssignment_1() { return cBodyAssignment_1; }

		//GExpression
		public RuleCall getBodyGExpressionParserRuleCall_1_0() { return cBodyGExpressionParserRuleCall_1_0; }
	}

	public class DomainSpecificEventsPatternElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DomainSpecificEventsPattern");
		private final RuleCall cLogicalSequenceParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//DomainSpecificEventsPattern returns gel::DomainSpecificEventsPattern:
		//	LogicalSequence;
		public ParserRule getRule() { return rule; }

		//LogicalSequence
		public RuleCall getLogicalSequenceParserRuleCall() { return cLogicalSequenceParserRuleCall; }
	}

	public class LogicalSequenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalSequence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCoincidencePatternParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLogicalSequenceLeftOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cHyphenMinusHyphenMinusHyphenMinusGreaterThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOperandCoincidencePatternParserRuleCall_1_2_0 = (RuleCall)cRightOperandAssignment_1_2.eContents().get(0);
		
		//LogicalSequence returns gel::DomainSpecificEventsPattern:
		//	CoincidencePattern ({gel::LogicalSequence.leftOperand=current} => "--->" rightOperand=CoincidencePattern)*;
		public ParserRule getRule() { return rule; }

		//CoincidencePattern ({gel::LogicalSequence.leftOperand=current} => "--->" rightOperand=CoincidencePattern)*
		public Group getGroup() { return cGroup; }

		//CoincidencePattern
		public RuleCall getCoincidencePatternParserRuleCall_0() { return cCoincidencePatternParserRuleCall_0; }

		//({gel::LogicalSequence.leftOperand=current} => "--->" rightOperand=CoincidencePattern)*
		public Group getGroup_1() { return cGroup_1; }

		//{gel::LogicalSequence.leftOperand=current}
		public Action getLogicalSequenceLeftOperandAction_1_0() { return cLogicalSequenceLeftOperandAction_1_0; }

		//=> "--->"
		public Keyword getHyphenMinusHyphenMinusHyphenMinusGreaterThanSignKeyword_1_1() { return cHyphenMinusHyphenMinusHyphenMinusGreaterThanSignKeyword_1_1; }

		//rightOperand=CoincidencePattern
		public Assignment getRightOperandAssignment_1_2() { return cRightOperandAssignment_1_2; }

		//CoincidencePattern
		public RuleCall getRightOperandCoincidencePatternParserRuleCall_1_2_0() { return cRightOperandCoincidencePatternParserRuleCall_1_2_0; }
	}

	public class CoincidencePatternElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CoincidencePattern");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrPatternParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cCoincidencePatternLeftOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOperandOrPatternParserRuleCall_1_2_0 = (RuleCall)cRightOperandAssignment_1_2.eContents().get(0);
		
		//CoincidencePattern returns gel::DomainSpecificEventsPattern:
		//	OrPattern ({gel::CoincidencePattern.leftOperand=current} "&" rightOperand=OrPattern)*;
		public ParserRule getRule() { return rule; }

		//OrPattern ({gel::CoincidencePattern.leftOperand=current} "&" rightOperand=OrPattern)*
		public Group getGroup() { return cGroup; }

		//OrPattern
		public RuleCall getOrPatternParserRuleCall_0() { return cOrPatternParserRuleCall_0; }

		//({gel::CoincidencePattern.leftOperand=current} "&" rightOperand=OrPattern)*
		public Group getGroup_1() { return cGroup_1; }

		//{gel::CoincidencePattern.leftOperand=current}
		public Action getCoincidencePatternLeftOperandAction_1_0() { return cCoincidencePatternLeftOperandAction_1_0; }

		//"&"
		public Keyword getAmpersandKeyword_1_1() { return cAmpersandKeyword_1_1; }

		//rightOperand=OrPattern
		public Assignment getRightOperandAssignment_1_2() { return cRightOperandAssignment_1_2; }

		//OrPattern
		public RuleCall getRightOperandOrPatternParserRuleCall_1_2_0() { return cRightOperandOrPatternParserRuleCall_1_2_0; }
	}

	public class OrPatternElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OrPattern");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXorPatternParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrPatternLeftOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOperandXorPatternParserRuleCall_1_2_0 = (RuleCall)cRightOperandAssignment_1_2.eContents().get(0);
		
		//OrPattern returns gel::DomainSpecificEventsPattern:
		//	XorPattern ({gel::OrPattern.leftOperand=current} "|" rightOperand=XorPattern)*;
		public ParserRule getRule() { return rule; }

		//XorPattern ({gel::OrPattern.leftOperand=current} "|" rightOperand=XorPattern)*
		public Group getGroup() { return cGroup; }

		//XorPattern
		public RuleCall getXorPatternParserRuleCall_0() { return cXorPatternParserRuleCall_0; }

		//({gel::OrPattern.leftOperand=current} "|" rightOperand=XorPattern)*
		public Group getGroup_1() { return cGroup_1; }

		//{gel::OrPattern.leftOperand=current}
		public Action getOrPatternLeftOperandAction_1_0() { return cOrPatternLeftOperandAction_1_0; }

		//"|"
		public Keyword getVerticalLineKeyword_1_1() { return cVerticalLineKeyword_1_1; }

		//rightOperand=XorPattern
		public Assignment getRightOperandAssignment_1_2() { return cRightOperandAssignment_1_2; }

		//XorPattern
		public RuleCall getRightOperandXorPatternParserRuleCall_1_2_0() { return cRightOperandXorPatternParserRuleCall_1_2_0; }
	}

	public class XorPatternElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "XorPattern");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPlusPatternParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cXorPatternLeftOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cGreaterThanSignLessThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOperandPlusPatternParserRuleCall_1_2_0 = (RuleCall)cRightOperandAssignment_1_2.eContents().get(0);
		
		//XorPattern returns gel::DomainSpecificEventsPattern:
		//	PlusPattern ({gel::XorPattern.leftOperand=current} "><" rightOperand=PlusPattern)*;
		public ParserRule getRule() { return rule; }

		//PlusPattern ({gel::XorPattern.leftOperand=current} "><" rightOperand=PlusPattern)*
		public Group getGroup() { return cGroup; }

		//PlusPattern
		public RuleCall getPlusPatternParserRuleCall_0() { return cPlusPatternParserRuleCall_0; }

		//({gel::XorPattern.leftOperand=current} "><" rightOperand=PlusPattern)*
		public Group getGroup_1() { return cGroup_1; }

		//{gel::XorPattern.leftOperand=current}
		public Action getXorPatternLeftOperandAction_1_0() { return cXorPatternLeftOperandAction_1_0; }

		//"><"
		public Keyword getGreaterThanSignLessThanSignKeyword_1_1() { return cGreaterThanSignLessThanSignKeyword_1_1; }

		//rightOperand=PlusPattern
		public Assignment getRightOperandAssignment_1_2() { return cRightOperandAssignment_1_2; }

		//PlusPattern
		public RuleCall getRightOperandPlusPatternParserRuleCall_1_2_0() { return cRightOperandPlusPatternParserRuleCall_1_2_0; }
	}

	public class PlusPatternElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PlusPattern");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIterationPatternParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPlusPatternOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//PlusPattern returns gel::DomainSpecificEventsPattern:
		//	IterationPattern ({gel::PlusPattern.operand=current} "+")?;
		public ParserRule getRule() { return rule; }

		//IterationPattern ({gel::PlusPattern.operand=current} "+")?
		public Group getGroup() { return cGroup; }

		//IterationPattern
		public RuleCall getIterationPatternParserRuleCall_0() { return cIterationPatternParserRuleCall_0; }

		//({gel::PlusPattern.operand=current} "+")?
		public Group getGroup_1() { return cGroup_1; }

		//{gel::PlusPattern.operand=current}
		public Action getPlusPatternOperandAction_1_0() { return cPlusPatternOperandAction_1_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }
	}

	public class IterationPatternElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IterationPattern");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDomainSpecificEventReferenceOrPatternParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cIterationPatternOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cNumberOfIterationsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cNumberOfIterationsINTTerminalRuleCall_1_2_0 = (RuleCall)cNumberOfIterationsAssignment_1_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//IterationPattern returns gel::DomainSpecificEventsPattern:
		//	DomainSpecificEventReferenceOrPattern ({gel::IterationPattern.operand=current} "[" numberOfIterations=INT "]")?;
		public ParserRule getRule() { return rule; }

		//DomainSpecificEventReferenceOrPattern ({gel::IterationPattern.operand=current} "[" numberOfIterations=INT "]")?
		public Group getGroup() { return cGroup; }

		//DomainSpecificEventReferenceOrPattern
		public RuleCall getDomainSpecificEventReferenceOrPatternParserRuleCall_0() { return cDomainSpecificEventReferenceOrPatternParserRuleCall_0; }

		//({gel::IterationPattern.operand=current} "[" numberOfIterations=INT "]")?
		public Group getGroup_1() { return cGroup_1; }

		//{gel::IterationPattern.operand=current}
		public Action getIterationPatternOperandAction_1_0() { return cIterationPatternOperandAction_1_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_1() { return cLeftSquareBracketKeyword_1_1; }

		//numberOfIterations=INT
		public Assignment getNumberOfIterationsAssignment_1_2() { return cNumberOfIterationsAssignment_1_2; }

		//INT
		public RuleCall getNumberOfIterationsINTTerminalRuleCall_1_2_0() { return cNumberOfIterationsINTTerminalRuleCall_1_2_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_3() { return cRightSquareBracketKeyword_1_3; }
	}

	public class DomainSpecificEventReferenceOrPatternElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DomainSpecificEventReferenceOrPattern");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDomainSpecificEventReferenceWithOrWithoutTargetParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cDomainSpecificEventsPatternParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//DomainSpecificEventReferenceOrPattern returns gel::DomainSpecificEventsPattern:
		//	DomainSpecificEventReferenceWithOrWithoutTarget | "(" DomainSpecificEventsPattern ")";
		public ParserRule getRule() { return rule; }

		//DomainSpecificEventReferenceWithOrWithoutTarget | "(" DomainSpecificEventsPattern ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//DomainSpecificEventReferenceWithOrWithoutTarget
		public RuleCall getDomainSpecificEventReferenceWithOrWithoutTargetParserRuleCall_0() { return cDomainSpecificEventReferenceWithOrWithoutTargetParserRuleCall_0; }

		//"(" DomainSpecificEventsPattern ")"
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//DomainSpecificEventsPattern
		public RuleCall getDomainSpecificEventsPatternParserRuleCall_1_1() { return cDomainSpecificEventsPatternParserRuleCall_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class DomainSpecificEventReferenceWithOrWithoutTargetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DomainSpecificEventReferenceWithOrWithoutTarget");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDomainSpecificEventReferenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDomainSpecificEventReferenceWithArgumentsParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//DomainSpecificEventReferenceWithOrWithoutTarget returns gel::DomainSpecificEventsPattern:
		//	DomainSpecificEventReference | DomainSpecificEventReferenceWithArguments;
		public ParserRule getRule() { return rule; }

		//DomainSpecificEventReference | DomainSpecificEventReferenceWithArguments
		public Alternatives getAlternatives() { return cAlternatives; }

		//DomainSpecificEventReference
		public RuleCall getDomainSpecificEventReferenceParserRuleCall_0() { return cDomainSpecificEventReferenceParserRuleCall_0; }

		//DomainSpecificEventReferenceWithArguments
		public RuleCall getDomainSpecificEventReferenceWithArgumentsParserRuleCall_1() { return cDomainSpecificEventReferenceWithArgumentsParserRuleCall_1; }
	}

	public class DomainSpecificEventReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DomainSpecificEventReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDomainSpecificEventReferenceAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cReferencedDseAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cReferencedDseDomainSpecificEventCrossReference_1_0 = (CrossReference)cReferencedDseAssignment_1.eContents().get(0);
		private final RuleCall cReferencedDseDomainSpecificEventIDTerminalRuleCall_1_0_1 = (RuleCall)cReferencedDseDomainSpecificEventCrossReference_1_0.eContents().get(1);
		
		//DomainSpecificEventReference returns gel::DomainSpecificEventsPattern:
		//	{gel::DomainSpecificEventReference} referencedDse=[gel::DomainSpecificEvent];
		public ParserRule getRule() { return rule; }

		//{gel::DomainSpecificEventReference} referencedDse=[gel::DomainSpecificEvent]
		public Group getGroup() { return cGroup; }

		//{gel::DomainSpecificEventReference}
		public Action getDomainSpecificEventReferenceAction_0() { return cDomainSpecificEventReferenceAction_0; }

		//referencedDse=[gel::DomainSpecificEvent]
		public Assignment getReferencedDseAssignment_1() { return cReferencedDseAssignment_1; }

		//[gel::DomainSpecificEvent]
		public CrossReference getReferencedDseDomainSpecificEventCrossReference_1_0() { return cReferencedDseDomainSpecificEventCrossReference_1_0; }

		//ID
		public RuleCall getReferencedDseDomainSpecificEventIDTerminalRuleCall_1_0_1() { return cReferencedDseDomainSpecificEventIDTerminalRuleCall_1_0_1; }
	}

	public class DomainSpecificEventReferenceWithArgumentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DomainSpecificEventReferenceWithArguments");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDomainSpecificEventReferenceWithArgumentsAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cReferencedDseAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cReferencedDseDomainSpecificEventCrossReference_1_0 = (CrossReference)cReferencedDseAssignment_1.eContents().get(0);
		private final RuleCall cReferencedDseDomainSpecificEventIDTerminalRuleCall_1_0_1 = (RuleCall)cReferencedDseDomainSpecificEventCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cArgumentsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cArgumentsListOfArgumentsParserRuleCall_3_0 = (RuleCall)cArgumentsAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//DomainSpecificEventReferenceWithArguments returns gel::DomainSpecificEventsPattern:
		//	{gel::DomainSpecificEventReferenceWithArguments} referencedDse=[gel::DomainSpecificEvent] "("
		//	arguments=ListOfArguments ")";
		public ParserRule getRule() { return rule; }

		//{gel::DomainSpecificEventReferenceWithArguments} referencedDse=[gel::DomainSpecificEvent] "(" arguments=ListOfArguments
		//")"
		public Group getGroup() { return cGroup; }

		//{gel::DomainSpecificEventReferenceWithArguments}
		public Action getDomainSpecificEventReferenceWithArgumentsAction_0() { return cDomainSpecificEventReferenceWithArgumentsAction_0; }

		//referencedDse=[gel::DomainSpecificEvent]
		public Assignment getReferencedDseAssignment_1() { return cReferencedDseAssignment_1; }

		//[gel::DomainSpecificEvent]
		public CrossReference getReferencedDseDomainSpecificEventCrossReference_1_0() { return cReferencedDseDomainSpecificEventCrossReference_1_0; }

		//ID
		public RuleCall getReferencedDseDomainSpecificEventIDTerminalRuleCall_1_0_1() { return cReferencedDseDomainSpecificEventIDTerminalRuleCall_1_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//arguments=ListOfArguments
		public Assignment getArgumentsAssignment_3() { return cArgumentsAssignment_3; }

		//ListOfArguments
		public RuleCall getArgumentsListOfArgumentsParserRuleCall_3_0() { return cArgumentsListOfArgumentsParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class ListOfArgumentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ListOfArguments");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSingleArgumentParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMultipleArgumentsParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ListOfArguments returns gel::ListOfArguments:
		//	SingleArgument | MultipleArguments;
		public ParserRule getRule() { return rule; }

		//SingleArgument | MultipleArguments
		public Alternatives getAlternatives() { return cAlternatives; }

		//SingleArgument
		public RuleCall getSingleArgumentParserRuleCall_0() { return cSingleArgumentParserRuleCall_0; }

		//MultipleArguments
		public RuleCall getMultipleArgumentsParserRuleCall_1() { return cMultipleArgumentsParserRuleCall_1; }
	}

	public class SingleArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SingleArgument");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSingleArgumentAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cArgumentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cArgumentLocalVariableCrossReference_1_0 = (CrossReference)cArgumentAssignment_1.eContents().get(0);
		private final RuleCall cArgumentLocalVariableIDTerminalRuleCall_1_0_1 = (RuleCall)cArgumentLocalVariableCrossReference_1_0.eContents().get(1);
		
		//SingleArgument returns gel::ListOfArguments:
		//	{gel::SingleArgument} argument=[gel::LocalVariable];
		public ParserRule getRule() { return rule; }

		//{gel::SingleArgument} argument=[gel::LocalVariable]
		public Group getGroup() { return cGroup; }

		//{gel::SingleArgument}
		public Action getSingleArgumentAction_0() { return cSingleArgumentAction_0; }

		//argument=[gel::LocalVariable]
		public Assignment getArgumentAssignment_1() { return cArgumentAssignment_1; }

		//[gel::LocalVariable]
		public CrossReference getArgumentLocalVariableCrossReference_1_0() { return cArgumentLocalVariableCrossReference_1_0; }

		//ID
		public RuleCall getArgumentLocalVariableIDTerminalRuleCall_1_0_1() { return cArgumentLocalVariableIDTerminalRuleCall_1_0_1; }
	}

	public class MultipleArgumentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultipleArguments");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cMultipleArgumentsAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cHeadAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cHeadLocalVariableCrossReference_1_0 = (CrossReference)cHeadAssignment_1.eContents().get(0);
		private final RuleCall cHeadLocalVariableIDTerminalRuleCall_1_0_1 = (RuleCall)cHeadLocalVariableCrossReference_1_0.eContents().get(1);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTailAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTailListOfArgumentsParserRuleCall_3_0 = (RuleCall)cTailAssignment_3.eContents().get(0);
		
		//MultipleArguments returns gel::ListOfArguments:
		//	{gel::MultipleArguments} head=[gel::LocalVariable] "," tail=ListOfArguments;
		public ParserRule getRule() { return rule; }

		//{gel::MultipleArguments} head=[gel::LocalVariable] "," tail=ListOfArguments
		public Group getGroup() { return cGroup; }

		//{gel::MultipleArguments}
		public Action getMultipleArgumentsAction_0() { return cMultipleArgumentsAction_0; }

		//head=[gel::LocalVariable]
		public Assignment getHeadAssignment_1() { return cHeadAssignment_1; }

		//[gel::LocalVariable]
		public CrossReference getHeadLocalVariableCrossReference_1_0() { return cHeadLocalVariableCrossReference_1_0; }

		//ID
		public RuleCall getHeadLocalVariableIDTerminalRuleCall_1_0_1() { return cHeadLocalVariableIDTerminalRuleCall_1_0_1; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//tail=ListOfArguments
		public Assignment getTailAssignment_3() { return cTailAssignment_3; }

		//ListOfArguments
		public RuleCall getTailListOfArgumentsParserRuleCall_3_0() { return cTailListOfArgumentsParserRuleCall_3_0; }
	}

	public class FeedbackPolicyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FeedbackPolicy");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFeedbackPolicyAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cRulesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRulesFeedbackRuleParserRuleCall_1_0 = (RuleCall)cRulesAssignment_1.eContents().get(0);
		private final Assignment cDefaultRuleAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDefaultRuleDefaultFeedbackRuleParserRuleCall_2_0 = (RuleCall)cDefaultRuleAssignment_2.eContents().get(0);
		
		//// End
		////-----------------------------------------------------------------------------
		//// Feedback Policy stuff
		////-----------------------------------------------------------------------------
		//FeedbackPolicy returns gel::FeedbackPolicy:
		//	{gel::FeedbackPolicy} rules+=FeedbackRule* defaultRule=DefaultFeedbackRule;
		public ParserRule getRule() { return rule; }

		//{gel::FeedbackPolicy} rules+=FeedbackRule* defaultRule=DefaultFeedbackRule
		public Group getGroup() { return cGroup; }

		//{gel::FeedbackPolicy}
		public Action getFeedbackPolicyAction_0() { return cFeedbackPolicyAction_0; }

		//rules+=FeedbackRule*
		public Assignment getRulesAssignment_1() { return cRulesAssignment_1; }

		//FeedbackRule
		public RuleCall getRulesFeedbackRuleParserRuleCall_1_0() { return cRulesFeedbackRuleParserRuleCall_1_0; }

		//defaultRule=DefaultFeedbackRule
		public Assignment getDefaultRuleAssignment_2() { return cDefaultRuleAssignment_2; }

		//DefaultFeedbackRule
		public RuleCall getDefaultRuleDefaultFeedbackRuleParserRuleCall_2_0() { return cDefaultRuleDefaultFeedbackRuleParserRuleCall_2_0; }
	}

	public class FeedbackRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FeedbackRule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFeedbackRuleAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cFilterAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFilterFeedbackFilterParserRuleCall_2_0 = (RuleCall)cFilterAssignment_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cEqualsSignGreaterThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cConsequenceAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cConsequenceFeedbackConsequenceParserRuleCall_5_0 = (RuleCall)cConsequenceAssignment_5.eContents().get(0);
		
		//FeedbackRule returns gel::FeedbackRule:
		//	{gel::FeedbackRule} "[" filter=FeedbackFilter "]" "=>" consequence=FeedbackConsequence;
		public ParserRule getRule() { return rule; }

		//{gel::FeedbackRule} "[" filter=FeedbackFilter "]" "=>" consequence=FeedbackConsequence
		public Group getGroup() { return cGroup; }

		//{gel::FeedbackRule}
		public Action getFeedbackRuleAction_0() { return cFeedbackRuleAction_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }

		//filter=FeedbackFilter
		public Assignment getFilterAssignment_2() { return cFilterAssignment_2; }

		//FeedbackFilter
		public RuleCall getFilterFeedbackFilterParserRuleCall_2_0() { return cFilterFeedbackFilterParserRuleCall_2_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }

		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_4() { return cEqualsSignGreaterThanSignKeyword_4; }

		//consequence=FeedbackConsequence
		public Assignment getConsequenceAssignment_5() { return cConsequenceAssignment_5; }

		//FeedbackConsequence
		public RuleCall getConsequenceFeedbackConsequenceParserRuleCall_5_0() { return cConsequenceFeedbackConsequenceParserRuleCall_5_0; }
	}

	public class DefaultFeedbackRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DefaultFeedbackRule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFeedbackRuleAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cDefaultKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEqualsSignGreaterThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cConsequenceAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cConsequenceFeedbackConsequenceParserRuleCall_3_0 = (RuleCall)cConsequenceAssignment_3.eContents().get(0);
		
		//DefaultFeedbackRule returns gel::FeedbackRule:
		//	{gel::FeedbackRule} "default" "=>" consequence=FeedbackConsequence;
		public ParserRule getRule() { return rule; }

		//{gel::FeedbackRule} "default" "=>" consequence=FeedbackConsequence
		public Group getGroup() { return cGroup; }

		//{gel::FeedbackRule}
		public Action getFeedbackRuleAction_0() { return cFeedbackRuleAction_0; }

		//"default"
		public Keyword getDefaultKeyword_1() { return cDefaultKeyword_1; }

		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_2() { return cEqualsSignGreaterThanSignKeyword_2; }

		//consequence=FeedbackConsequence
		public Assignment getConsequenceAssignment_3() { return cConsequenceAssignment_3; }

		//FeedbackConsequence
		public RuleCall getConsequenceFeedbackConsequenceParserRuleCall_3_0() { return cConsequenceFeedbackConsequenceParserRuleCall_3_0; }
	}

	public class FeedbackFilterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FeedbackFilter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFeedbackFilterAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBodyGExpressionParserRuleCall_1_0 = (RuleCall)cBodyAssignment_1.eContents().get(0);
		
		//FeedbackFilter returns gel::FeedbackFilter:
		//	{gel::FeedbackFilter} body=GExpression;
		public ParserRule getRule() { return rule; }

		//{gel::FeedbackFilter} body=GExpression
		public Group getGroup() { return cGroup; }

		//{gel::FeedbackFilter}
		public Action getFeedbackFilterAction_0() { return cFeedbackFilterAction_0; }

		//body=GExpression
		public Assignment getBodyAssignment_1() { return cBodyAssignment_1; }

		//GExpression
		public RuleCall getBodyGExpressionParserRuleCall_1_0() { return cBodyGExpressionParserRuleCall_1_0; }
	}

	public class FeedbackConsequenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FeedbackConsequence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFeedbackConsequenceAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cAllowKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNavigationPathToMoccEventAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNavigationPathToMoccEventGExpressionParserRuleCall_2_0 = (RuleCall)cNavigationPathToMoccEventAssignment_2.eContents().get(0);
		
		//FeedbackConsequence returns gel::FeedbackConsequence:
		//	{gel::FeedbackConsequence} "allow" navigationPathToMoccEvent=GExpression;
		public ParserRule getRule() { return rule; }

		//{gel::FeedbackConsequence} "allow" navigationPathToMoccEvent=GExpression
		public Group getGroup() { return cGroup; }

		//{gel::FeedbackConsequence}
		public Action getFeedbackConsequenceAction_0() { return cFeedbackConsequenceAction_0; }

		//"allow"
		public Keyword getAllowKeyword_1() { return cAllowKeyword_1; }

		//navigationPathToMoccEvent=GExpression
		public Assignment getNavigationPathToMoccEventAssignment_2() { return cNavigationPathToMoccEventAssignment_2; }

		//GExpression
		public RuleCall getNavigationPathToMoccEventGExpressionParserRuleCall_2_0() { return cNavigationPathToMoccEventGExpressionParserRuleCall_2_0; }
	}

	public class MoccEventElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MoccEvent");
		private final RuleCall cEclEventParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// End
		////-----------------------------------------------------------------------------
		//// Imported from the MoCC
		////-----------------------------------------------------------------------------
		//MoccEvent returns gel::MoccEvent:
		//	EclEvent;
		public ParserRule getRule() { return rule; }

		//EclEvent
		public RuleCall getEclEventParserRuleCall() { return cEclEventParserRuleCall; }
	}

	public class EclEventElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EclEvent");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cEclEventAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cEventReferenceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cEventReferenceECLDefCSCrossReference_1_0 = (CrossReference)cEventReferenceAssignment_1.eContents().get(0);
		private final RuleCall cEventReferenceECLDefCSQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cEventReferenceECLDefCSCrossReference_1_0.eContents().get(1);
		
		//EclEvent returns gel::MoccEvent:
		//	{gel::EclEvent} eventReference=[ecl::ECLDefCS|QualifiedName];
		public ParserRule getRule() { return rule; }

		//{gel::EclEvent} eventReference=[ecl::ECLDefCS|QualifiedName]
		public Group getGroup() { return cGroup; }

		//{gel::EclEvent}
		public Action getEclEventAction_0() { return cEclEventAction_0; }

		//eventReference=[ecl::ECLDefCS|QualifiedName]
		public Assignment getEventReferenceAssignment_1() { return cEventReferenceAssignment_1; }

		//[ecl::ECLDefCS|QualifiedName]
		public CrossReference getEventReferenceECLDefCSCrossReference_1_0() { return cEventReferenceECLDefCSCrossReference_1_0; }

		//QualifiedName
		public RuleCall getEventReferenceECLDefCSQualifiedNameParserRuleCall_1_0_1() { return cEventReferenceECLDefCSQualifiedNameParserRuleCall_1_0_1; }
	}

	public class ExecutionFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExecutionFunction");
		private final RuleCall cKermeta3ExecutionFunctionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// End
		////-----------------------------------------------------------------------------
		//// Imported from the DSA
		////-----------------------------------------------------------------------------
		//ExecutionFunction returns gel::ExecutionFunction:
		//	Kermeta3ExecutionFunction;
		public ParserRule getRule() { return rule; }

		//Kermeta3ExecutionFunction
		public RuleCall getKermeta3ExecutionFunctionParserRuleCall() { return cKermeta3ExecutionFunctionParserRuleCall; }
	}

	public class Kermeta3ExecutionFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Kermeta3ExecutionFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cKermeta3ExecutionFunctionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNavigationPathToOperationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNavigationPathToOperationGExpressionParserRuleCall_1_0 = (RuleCall)cNavigationPathToOperationAssignment_1.eContents().get(0);
		private final Assignment cCallKindAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCallKindCallKindEnumRuleCall_2_0 = (RuleCall)cCallKindAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cReturningKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cResultAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cResultExecutionFunctionResultParserRuleCall_3_1_0 = (RuleCall)cResultAssignment_3_1.eContents().get(0);
		
		//Kermeta3ExecutionFunction returns gel::ExecutionFunction:
		//	{gel::Kermeta3ExecutionFunction} navigationPathToOperation=GExpression callKind=CallKind? ("returning"
		//	result=ExecutionFunctionResult)?;
		public ParserRule getRule() { return rule; }

		//{gel::Kermeta3ExecutionFunction} navigationPathToOperation=GExpression callKind=CallKind? ("returning"
		//result=ExecutionFunctionResult)?
		public Group getGroup() { return cGroup; }

		//{gel::Kermeta3ExecutionFunction}
		public Action getKermeta3ExecutionFunctionAction_0() { return cKermeta3ExecutionFunctionAction_0; }

		//navigationPathToOperation=GExpression
		public Assignment getNavigationPathToOperationAssignment_1() { return cNavigationPathToOperationAssignment_1; }

		//GExpression
		public RuleCall getNavigationPathToOperationGExpressionParserRuleCall_1_0() { return cNavigationPathToOperationGExpressionParserRuleCall_1_0; }

		//callKind=CallKind?
		public Assignment getCallKindAssignment_2() { return cCallKindAssignment_2; }

		//CallKind
		public RuleCall getCallKindCallKindEnumRuleCall_2_0() { return cCallKindCallKindEnumRuleCall_2_0; }

		//("returning" result=ExecutionFunctionResult)?
		public Group getGroup_3() { return cGroup_3; }

		//"returning"
		public Keyword getReturningKeyword_3_0() { return cReturningKeyword_3_0; }

		//result=ExecutionFunctionResult
		public Assignment getResultAssignment_3_1() { return cResultAssignment_3_1; }

		//ExecutionFunctionResult
		public RuleCall getResultExecutionFunctionResultParserRuleCall_3_1_0() { return cResultExecutionFunctionResultParserRuleCall_3_1_0; }
	}

	public class ExecutionFunctionResultElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExecutionFunctionResult");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cExecutionFunctionResultAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//ExecutionFunctionResult returns gel::ExecutionFunctionResult:
		//	{gel::ExecutionFunctionResult} name=ID;
		public ParserRule getRule() { return rule; }

		//{gel::ExecutionFunctionResult} name=ID
		public Group getGroup() { return cGroup; }

		//{gel::ExecutionFunctionResult}
		public Action getExecutionFunctionResultAction_0() { return cExecutionFunctionResultAction_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}

	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//// End QualifiedName returns ecore::EString:
		//	ID ("." ID)*;
		public ParserRule getRule() { return rule; }

		//ID ("." ID)*
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//(=> "." ID)*
		public Group getGroup_1() { return cGroup_1; }

		//=> "."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}
	
	
	public class VisibilityElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "Visibility");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPublicEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPublicPublicKeyword_0_0 = (Keyword)cPublicEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPrivateEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPrivatePrivateKeyword_1_0 = (Keyword)cPrivateEnumLiteralDeclaration_1.eContents().get(0);
		
		//// End
		//// Additional stuff
		//enum Visibility returns gel::Visibility:
		//	public | private;
		public EnumRule getRule() { return rule; }

		//public | private
		public Alternatives getAlternatives() { return cAlternatives; }

		//public
		public EnumLiteralDeclaration getPublicEnumLiteralDeclaration_0() { return cPublicEnumLiteralDeclaration_0; }

		//"public"
		public Keyword getPublicPublicKeyword_0_0() { return cPublicPublicKeyword_0_0; }

		//private
		public EnumLiteralDeclaration getPrivateEnumLiteralDeclaration_1() { return cPrivateEnumLiteralDeclaration_1; }

		//"private"
		public Keyword getPrivatePrivateKeyword_1_0() { return cPrivatePrivateKeyword_1_0; }
	}

	public class ExecutionKindElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ExecutionKind");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSubmissionEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSubmissionTriggersKeyword_0_0 = (Keyword)cSubmissionEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cInterruptionEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cInterruptionInterruptsKeyword_1_0 = (Keyword)cInterruptionEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ExecutionKind returns gel::ExecutionKind:
		//	submission="triggers" | interruption="interrupts";
		public EnumRule getRule() { return rule; }

		//submission="triggers" | interruption="interrupts"
		public Alternatives getAlternatives() { return cAlternatives; }

		//submission="triggers"
		public EnumLiteralDeclaration getSubmissionEnumLiteralDeclaration_0() { return cSubmissionEnumLiteralDeclaration_0; }

		//"triggers"
		public Keyword getSubmissionTriggersKeyword_0_0() { return cSubmissionTriggersKeyword_0_0; }

		//interruption="interrupts"
		public EnumLiteralDeclaration getInterruptionEnumLiteralDeclaration_1() { return cInterruptionEnumLiteralDeclaration_1; }

		//"interrupts"
		public Keyword getInterruptionInterruptsKeyword_1_0() { return cInterruptionInterruptsKeyword_1_0; }
	}

	public class CallKindElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "CallKind");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cBlockingEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cBlockingBlockingKeyword_0_0 = (Keyword)cBlockingEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNonBlockingEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNonBlockingNonblockingKeyword_1_0 = (Keyword)cNonBlockingEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum CallKind returns gel::CallKind:
		//	blocking | nonBlocking="nonblocking";
		public EnumRule getRule() { return rule; }

		//blocking | nonBlocking="nonblocking"
		public Alternatives getAlternatives() { return cAlternatives; }

		//blocking
		public EnumLiteralDeclaration getBlockingEnumLiteralDeclaration_0() { return cBlockingEnumLiteralDeclaration_0; }

		//"blocking"
		public Keyword getBlockingBlockingKeyword_0_0() { return cBlockingBlockingKeyword_0_0; }

		//nonBlocking="nonblocking"
		public EnumLiteralDeclaration getNonBlockingEnumLiteralDeclaration_1() { return cNonBlockingEnumLiteralDeclaration_1; }

		//"nonblocking"
		public Keyword getNonBlockingNonblockingKeyword_1_0() { return cNonBlockingNonblockingKeyword_1_0; }
	}
	
	private final DomainSpecificEventsSpecificationElements pDomainSpecificEventsSpecification;
	private final ImportStatementElements pImportStatement;
	private final DomainSpecificEventElements pDomainSpecificEvent;
	private final AtomicDomainSpecificEventElements pAtomicDomainSpecificEvent;
	private final CompositeDomainSpecificEventElements pCompositeDomainSpecificEvent;
	private final UnfoldingStrategyElements pUnfoldingStrategy;
	private final LocalVariableElements pLocalVariable;
	private final InstantiationPredicateElements pInstantiationPredicate;
	private final DomainSpecificEventsPatternElements pDomainSpecificEventsPattern;
	private final LogicalSequenceElements pLogicalSequence;
	private final CoincidencePatternElements pCoincidencePattern;
	private final OrPatternElements pOrPattern;
	private final XorPatternElements pXorPattern;
	private final PlusPatternElements pPlusPattern;
	private final IterationPatternElements pIterationPattern;
	private final DomainSpecificEventReferenceOrPatternElements pDomainSpecificEventReferenceOrPattern;
	private final DomainSpecificEventReferenceWithOrWithoutTargetElements pDomainSpecificEventReferenceWithOrWithoutTarget;
	private final DomainSpecificEventReferenceElements pDomainSpecificEventReference;
	private final DomainSpecificEventReferenceWithArgumentsElements pDomainSpecificEventReferenceWithArguments;
	private final ListOfArgumentsElements pListOfArguments;
	private final SingleArgumentElements pSingleArgument;
	private final MultipleArgumentsElements pMultipleArguments;
	private final FeedbackPolicyElements pFeedbackPolicy;
	private final FeedbackRuleElements pFeedbackRule;
	private final DefaultFeedbackRuleElements pDefaultFeedbackRule;
	private final FeedbackFilterElements pFeedbackFilter;
	private final FeedbackConsequenceElements pFeedbackConsequence;
	private final MoccEventElements pMoccEvent;
	private final EclEventElements pEclEvent;
	private final ExecutionFunctionElements pExecutionFunction;
	private final Kermeta3ExecutionFunctionElements pKermeta3ExecutionFunction;
	private final ExecutionFunctionResultElements pExecutionFunctionResult;
	private final VisibilityElements unknownRuleVisibility;
	private final ExecutionKindElements unknownRuleExecutionKind;
	private final CallKindElements unknownRuleCallKind;
	private final QualifiedNameElements pQualifiedName;
	
	private final Grammar grammar;

	private final GExpressionsGrammarAccess gaGExpressions;

	@Inject
	public GELGrammarAccess(GrammarProvider grammarProvider,
		GExpressionsGrammarAccess gaGExpressions) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaGExpressions = gaGExpressions;
		this.pDomainSpecificEventsSpecification = new DomainSpecificEventsSpecificationElements();
		this.pImportStatement = new ImportStatementElements();
		this.pDomainSpecificEvent = new DomainSpecificEventElements();
		this.pAtomicDomainSpecificEvent = new AtomicDomainSpecificEventElements();
		this.pCompositeDomainSpecificEvent = new CompositeDomainSpecificEventElements();
		this.pUnfoldingStrategy = new UnfoldingStrategyElements();
		this.pLocalVariable = new LocalVariableElements();
		this.pInstantiationPredicate = new InstantiationPredicateElements();
		this.pDomainSpecificEventsPattern = new DomainSpecificEventsPatternElements();
		this.pLogicalSequence = new LogicalSequenceElements();
		this.pCoincidencePattern = new CoincidencePatternElements();
		this.pOrPattern = new OrPatternElements();
		this.pXorPattern = new XorPatternElements();
		this.pPlusPattern = new PlusPatternElements();
		this.pIterationPattern = new IterationPatternElements();
		this.pDomainSpecificEventReferenceOrPattern = new DomainSpecificEventReferenceOrPatternElements();
		this.pDomainSpecificEventReferenceWithOrWithoutTarget = new DomainSpecificEventReferenceWithOrWithoutTargetElements();
		this.pDomainSpecificEventReference = new DomainSpecificEventReferenceElements();
		this.pDomainSpecificEventReferenceWithArguments = new DomainSpecificEventReferenceWithArgumentsElements();
		this.pListOfArguments = new ListOfArgumentsElements();
		this.pSingleArgument = new SingleArgumentElements();
		this.pMultipleArguments = new MultipleArgumentsElements();
		this.pFeedbackPolicy = new FeedbackPolicyElements();
		this.pFeedbackRule = new FeedbackRuleElements();
		this.pDefaultFeedbackRule = new DefaultFeedbackRuleElements();
		this.pFeedbackFilter = new FeedbackFilterElements();
		this.pFeedbackConsequence = new FeedbackConsequenceElements();
		this.pMoccEvent = new MoccEventElements();
		this.pEclEvent = new EclEventElements();
		this.pExecutionFunction = new ExecutionFunctionElements();
		this.pKermeta3ExecutionFunction = new Kermeta3ExecutionFunctionElements();
		this.pExecutionFunctionResult = new ExecutionFunctionResultElements();
		this.unknownRuleVisibility = new VisibilityElements();
		this.unknownRuleExecutionKind = new ExecutionKindElements();
		this.unknownRuleCallKind = new CallKindElements();
		this.pQualifiedName = new QualifiedNameElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.gemoc.gel.GEL".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public GExpressionsGrammarAccess getGExpressionsGrammarAccess() {
		return gaGExpressions;
	}

	
	////import "http://www.gemoc.org/gel/SimpleOCL" as simpleocl
	////-----------------------------------------------------------------------------
	//// Main stuff
	////-----------------------------------------------------------------------------
	//DomainSpecificEventsSpecification returns gel::DomainSpecificEventsSpecification:
	//	{gel::DomainSpecificEventsSpecification} imports+=ImportStatement* events+=DomainSpecificEvent*;
	public DomainSpecificEventsSpecificationElements getDomainSpecificEventsSpecificationAccess() {
		return pDomainSpecificEventsSpecification;
	}
	
	public ParserRule getDomainSpecificEventsSpecificationRule() {
		return getDomainSpecificEventsSpecificationAccess().getRule();
	}

	//ImportStatement returns gel::ImportStatement:
	//	"import" importURI= / *('as' alias=ID)?* / STRING;
	public ImportStatementElements getImportStatementAccess() {
		return pImportStatement;
	}
	
	public ParserRule getImportStatementRule() {
		return getImportStatementAccess().getRule();
	}

	//DomainSpecificEvent returns gel::DomainSpecificEvent:
	//	AtomicDomainSpecificEvent | CompositeDomainSpecificEvent;
	public DomainSpecificEventElements getDomainSpecificEventAccess() {
		return pDomainSpecificEvent;
	}
	
	public ParserRule getDomainSpecificEventRule() {
		return getDomainSpecificEventAccess().getRule();
	}

	//AtomicDomainSpecificEvent returns gel::DomainSpecificEvent:
	//	{gel::AtomicDomainSpecificEvent} visibility=Visibility? "DSE" name=ID ":" "upon" uponMoccEvent=MoccEvent
	//	(executionKind=ExecutionKind executionFunction=ExecutionFunction ("feedback" ":" feedbackPolicy=FeedbackPolicy
	//	"end")?)? ("raises" raisedMoccEvent=MoccEvent)? "end";
	public AtomicDomainSpecificEventElements getAtomicDomainSpecificEventAccess() {
		return pAtomicDomainSpecificEvent;
	}
	
	public ParserRule getAtomicDomainSpecificEventRule() {
		return getAtomicDomainSpecificEventAccess().getRule();
	}

	//// End
	////-----------------------------------------------------------------------------
	//// Composite DSE stuff
	////-----------------------------------------------------------------------------
	//CompositeDomainSpecificEvent returns gel::DomainSpecificEvent:
	//	{gel::CompositeDomainSpecificEvent} visibility=Visibility? "Composite" name=ID ":"
	//	unfoldingStrategy=UnfoldingStrategy? body=DomainSpecificEventsPattern "end";
	public CompositeDomainSpecificEventElements getCompositeDomainSpecificEventAccess() {
		return pCompositeDomainSpecificEvent;
	}
	
	public ParserRule getCompositeDomainSpecificEventRule() {
		return getCompositeDomainSpecificEventAccess().getRule();
	}

	//UnfoldingStrategy returns gel::UnfoldingStrategy:
	//	{gel::UnfoldingStrategy} "forall" "{" localVariables+=LocalVariable+ "}" "where" "{"
	//	instantiationPredicates+=InstantiationPredicate+ "}";
	public UnfoldingStrategyElements getUnfoldingStrategyAccess() {
		return pUnfoldingStrategy;
	}
	
	public ParserRule getUnfoldingStrategyRule() {
		return getUnfoldingStrategyAccess().getRule();
	}

	//LocalVariable returns gel::LocalVariable:
	//	{gel::LocalVariable} name=ID ":" type=[ecore::EClassifier|QualifiedName];
	public LocalVariableElements getLocalVariableAccess() {
		return pLocalVariable;
	}
	
	public ParserRule getLocalVariableRule() {
		return getLocalVariableAccess().getRule();
	}

	//InstantiationPredicate returns gel::InstantiationPredicate:
	//	{gel::InstantiationPredicate} body=GExpression;
	public InstantiationPredicateElements getInstantiationPredicateAccess() {
		return pInstantiationPredicate;
	}
	
	public ParserRule getInstantiationPredicateRule() {
		return getInstantiationPredicateAccess().getRule();
	}

	//DomainSpecificEventsPattern returns gel::DomainSpecificEventsPattern:
	//	LogicalSequence;
	public DomainSpecificEventsPatternElements getDomainSpecificEventsPatternAccess() {
		return pDomainSpecificEventsPattern;
	}
	
	public ParserRule getDomainSpecificEventsPatternRule() {
		return getDomainSpecificEventsPatternAccess().getRule();
	}

	//LogicalSequence returns gel::DomainSpecificEventsPattern:
	//	CoincidencePattern ({gel::LogicalSequence.leftOperand=current} => "--->" rightOperand=CoincidencePattern)*;
	public LogicalSequenceElements getLogicalSequenceAccess() {
		return pLogicalSequence;
	}
	
	public ParserRule getLogicalSequenceRule() {
		return getLogicalSequenceAccess().getRule();
	}

	//CoincidencePattern returns gel::DomainSpecificEventsPattern:
	//	OrPattern ({gel::CoincidencePattern.leftOperand=current} "&" rightOperand=OrPattern)*;
	public CoincidencePatternElements getCoincidencePatternAccess() {
		return pCoincidencePattern;
	}
	
	public ParserRule getCoincidencePatternRule() {
		return getCoincidencePatternAccess().getRule();
	}

	//OrPattern returns gel::DomainSpecificEventsPattern:
	//	XorPattern ({gel::OrPattern.leftOperand=current} "|" rightOperand=XorPattern)*;
	public OrPatternElements getOrPatternAccess() {
		return pOrPattern;
	}
	
	public ParserRule getOrPatternRule() {
		return getOrPatternAccess().getRule();
	}

	//XorPattern returns gel::DomainSpecificEventsPattern:
	//	PlusPattern ({gel::XorPattern.leftOperand=current} "><" rightOperand=PlusPattern)*;
	public XorPatternElements getXorPatternAccess() {
		return pXorPattern;
	}
	
	public ParserRule getXorPatternRule() {
		return getXorPatternAccess().getRule();
	}

	//PlusPattern returns gel::DomainSpecificEventsPattern:
	//	IterationPattern ({gel::PlusPattern.operand=current} "+")?;
	public PlusPatternElements getPlusPatternAccess() {
		return pPlusPattern;
	}
	
	public ParserRule getPlusPatternRule() {
		return getPlusPatternAccess().getRule();
	}

	//IterationPattern returns gel::DomainSpecificEventsPattern:
	//	DomainSpecificEventReferenceOrPattern ({gel::IterationPattern.operand=current} "[" numberOfIterations=INT "]")?;
	public IterationPatternElements getIterationPatternAccess() {
		return pIterationPattern;
	}
	
	public ParserRule getIterationPatternRule() {
		return getIterationPatternAccess().getRule();
	}

	//DomainSpecificEventReferenceOrPattern returns gel::DomainSpecificEventsPattern:
	//	DomainSpecificEventReferenceWithOrWithoutTarget | "(" DomainSpecificEventsPattern ")";
	public DomainSpecificEventReferenceOrPatternElements getDomainSpecificEventReferenceOrPatternAccess() {
		return pDomainSpecificEventReferenceOrPattern;
	}
	
	public ParserRule getDomainSpecificEventReferenceOrPatternRule() {
		return getDomainSpecificEventReferenceOrPatternAccess().getRule();
	}

	//DomainSpecificEventReferenceWithOrWithoutTarget returns gel::DomainSpecificEventsPattern:
	//	DomainSpecificEventReference | DomainSpecificEventReferenceWithArguments;
	public DomainSpecificEventReferenceWithOrWithoutTargetElements getDomainSpecificEventReferenceWithOrWithoutTargetAccess() {
		return pDomainSpecificEventReferenceWithOrWithoutTarget;
	}
	
	public ParserRule getDomainSpecificEventReferenceWithOrWithoutTargetRule() {
		return getDomainSpecificEventReferenceWithOrWithoutTargetAccess().getRule();
	}

	//DomainSpecificEventReference returns gel::DomainSpecificEventsPattern:
	//	{gel::DomainSpecificEventReference} referencedDse=[gel::DomainSpecificEvent];
	public DomainSpecificEventReferenceElements getDomainSpecificEventReferenceAccess() {
		return pDomainSpecificEventReference;
	}
	
	public ParserRule getDomainSpecificEventReferenceRule() {
		return getDomainSpecificEventReferenceAccess().getRule();
	}

	//DomainSpecificEventReferenceWithArguments returns gel::DomainSpecificEventsPattern:
	//	{gel::DomainSpecificEventReferenceWithArguments} referencedDse=[gel::DomainSpecificEvent] "("
	//	arguments=ListOfArguments ")";
	public DomainSpecificEventReferenceWithArgumentsElements getDomainSpecificEventReferenceWithArgumentsAccess() {
		return pDomainSpecificEventReferenceWithArguments;
	}
	
	public ParserRule getDomainSpecificEventReferenceWithArgumentsRule() {
		return getDomainSpecificEventReferenceWithArgumentsAccess().getRule();
	}

	//ListOfArguments returns gel::ListOfArguments:
	//	SingleArgument | MultipleArguments;
	public ListOfArgumentsElements getListOfArgumentsAccess() {
		return pListOfArguments;
	}
	
	public ParserRule getListOfArgumentsRule() {
		return getListOfArgumentsAccess().getRule();
	}

	//SingleArgument returns gel::ListOfArguments:
	//	{gel::SingleArgument} argument=[gel::LocalVariable];
	public SingleArgumentElements getSingleArgumentAccess() {
		return pSingleArgument;
	}
	
	public ParserRule getSingleArgumentRule() {
		return getSingleArgumentAccess().getRule();
	}

	//MultipleArguments returns gel::ListOfArguments:
	//	{gel::MultipleArguments} head=[gel::LocalVariable] "," tail=ListOfArguments;
	public MultipleArgumentsElements getMultipleArgumentsAccess() {
		return pMultipleArguments;
	}
	
	public ParserRule getMultipleArgumentsRule() {
		return getMultipleArgumentsAccess().getRule();
	}

	//// End
	////-----------------------------------------------------------------------------
	//// Feedback Policy stuff
	////-----------------------------------------------------------------------------
	//FeedbackPolicy returns gel::FeedbackPolicy:
	//	{gel::FeedbackPolicy} rules+=FeedbackRule* defaultRule=DefaultFeedbackRule;
	public FeedbackPolicyElements getFeedbackPolicyAccess() {
		return pFeedbackPolicy;
	}
	
	public ParserRule getFeedbackPolicyRule() {
		return getFeedbackPolicyAccess().getRule();
	}

	//FeedbackRule returns gel::FeedbackRule:
	//	{gel::FeedbackRule} "[" filter=FeedbackFilter "]" "=>" consequence=FeedbackConsequence;
	public FeedbackRuleElements getFeedbackRuleAccess() {
		return pFeedbackRule;
	}
	
	public ParserRule getFeedbackRuleRule() {
		return getFeedbackRuleAccess().getRule();
	}

	//DefaultFeedbackRule returns gel::FeedbackRule:
	//	{gel::FeedbackRule} "default" "=>" consequence=FeedbackConsequence;
	public DefaultFeedbackRuleElements getDefaultFeedbackRuleAccess() {
		return pDefaultFeedbackRule;
	}
	
	public ParserRule getDefaultFeedbackRuleRule() {
		return getDefaultFeedbackRuleAccess().getRule();
	}

	//FeedbackFilter returns gel::FeedbackFilter:
	//	{gel::FeedbackFilter} body=GExpression;
	public FeedbackFilterElements getFeedbackFilterAccess() {
		return pFeedbackFilter;
	}
	
	public ParserRule getFeedbackFilterRule() {
		return getFeedbackFilterAccess().getRule();
	}

	//FeedbackConsequence returns gel::FeedbackConsequence:
	//	{gel::FeedbackConsequence} "allow" navigationPathToMoccEvent=GExpression;
	public FeedbackConsequenceElements getFeedbackConsequenceAccess() {
		return pFeedbackConsequence;
	}
	
	public ParserRule getFeedbackConsequenceRule() {
		return getFeedbackConsequenceAccess().getRule();
	}

	//// End
	////-----------------------------------------------------------------------------
	//// Imported from the MoCC
	////-----------------------------------------------------------------------------
	//MoccEvent returns gel::MoccEvent:
	//	EclEvent;
	public MoccEventElements getMoccEventAccess() {
		return pMoccEvent;
	}
	
	public ParserRule getMoccEventRule() {
		return getMoccEventAccess().getRule();
	}

	//EclEvent returns gel::MoccEvent:
	//	{gel::EclEvent} eventReference=[ecl::ECLDefCS|QualifiedName];
	public EclEventElements getEclEventAccess() {
		return pEclEvent;
	}
	
	public ParserRule getEclEventRule() {
		return getEclEventAccess().getRule();
	}

	//// End
	////-----------------------------------------------------------------------------
	//// Imported from the DSA
	////-----------------------------------------------------------------------------
	//ExecutionFunction returns gel::ExecutionFunction:
	//	Kermeta3ExecutionFunction;
	public ExecutionFunctionElements getExecutionFunctionAccess() {
		return pExecutionFunction;
	}
	
	public ParserRule getExecutionFunctionRule() {
		return getExecutionFunctionAccess().getRule();
	}

	//Kermeta3ExecutionFunction returns gel::ExecutionFunction:
	//	{gel::Kermeta3ExecutionFunction} navigationPathToOperation=GExpression callKind=CallKind? ("returning"
	//	result=ExecutionFunctionResult)?;
	public Kermeta3ExecutionFunctionElements getKermeta3ExecutionFunctionAccess() {
		return pKermeta3ExecutionFunction;
	}
	
	public ParserRule getKermeta3ExecutionFunctionRule() {
		return getKermeta3ExecutionFunctionAccess().getRule();
	}

	//ExecutionFunctionResult returns gel::ExecutionFunctionResult:
	//	{gel::ExecutionFunctionResult} name=ID;
	public ExecutionFunctionResultElements getExecutionFunctionResultAccess() {
		return pExecutionFunctionResult;
	}
	
	public ParserRule getExecutionFunctionResultRule() {
		return getExecutionFunctionResultAccess().getRule();
	}

	//// End
	//// Additional stuff
	//enum Visibility returns gel::Visibility:
	//	public | private;
	public VisibilityElements getVisibilityAccess() {
		return unknownRuleVisibility;
	}
	
	public EnumRule getVisibilityRule() {
		return getVisibilityAccess().getRule();
	}

	//enum ExecutionKind returns gel::ExecutionKind:
	//	submission="triggers" | interruption="interrupts";
	public ExecutionKindElements getExecutionKindAccess() {
		return unknownRuleExecutionKind;
	}
	
	public EnumRule getExecutionKindRule() {
		return getExecutionKindAccess().getRule();
	}

	//enum CallKind returns gel::CallKind:
	//	blocking | nonBlocking="nonblocking";
	public CallKindElements getCallKindAccess() {
		return unknownRuleCallKind;
	}
	
	public EnumRule getCallKindRule() {
		return getCallKindAccess().getRule();
	}

	//// End QualifiedName returns ecore::EString:
	//	ID ("." ID)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return pQualifiedName;
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}

	////-----------------------------------------------------------------------------
	//// Main and import in order to be able to test the language as standalone
	////-----------------------------------------------------------------------------
	//GProgram:
	//	imports+=GImportStatement* (expressions+=GExpression (";"? expressions+=GExpression)*)?;
	public GExpressionsGrammarAccess.GProgramElements getGProgramAccess() {
		return gaGExpressions.getGProgramAccess();
	}
	
	public ParserRule getGProgramRule() {
		return getGProgramAccess().getRule();
	}

	//GImportStatement:
	//	"import" importURI=STRING;
	public GExpressionsGrammarAccess.GImportStatementElements getGImportStatementAccess() {
		return gaGExpressions.getGImportStatementAccess();
	}
	
	public ParserRule getGImportStatementRule() {
		return getGImportStatementAccess().getRule();
	}

	//GExpression:
	//	GOrExpression;
	public GExpressionsGrammarAccess.GExpressionElements getGExpressionAccess() {
		return gaGExpressions.getGExpressionAccess();
	}
	
	public ParserRule getGExpressionRule() {
		return getGExpressionAccess().getRule();
	}

	////-----------------------------------------------------------------------------
	//// Binary and unary operators, navigation, reference, ...
	////-----------------------------------------------------------------------------
	//GOrExpression returns GExpression:
	//	GXorExpression ({GOrExpression.leftOperand=current} operator=GOrOperator rightOperand=GXorExpression)*;
	public GExpressionsGrammarAccess.GOrExpressionElements getGOrExpressionAccess() {
		return gaGExpressions.getGOrExpressionAccess();
	}
	
	public ParserRule getGOrExpressionRule() {
		return getGOrExpressionAccess().getRule();
	}

	//GXorExpression returns GExpression:
	//	GAndExpression ({GXorExpression.leftOperand=current} operator=GXorOperator rightOperand=GAndExpression)*;
	public GExpressionsGrammarAccess.GXorExpressionElements getGXorExpressionAccess() {
		return gaGExpressions.getGXorExpressionAccess();
	}
	
	public ParserRule getGXorExpressionRule() {
		return getGXorExpressionAccess().getRule();
	}

	//GAndExpression returns GExpression:
	//	GEqualityExpression ({GAndExpression.leftOperand=current} operator=GAndOperator rightOperand=GEqualityExpression)*;
	public GExpressionsGrammarAccess.GAndExpressionElements getGAndExpressionAccess() {
		return gaGExpressions.getGAndExpressionAccess();
	}
	
	public ParserRule getGAndExpressionRule() {
		return getGAndExpressionAccess().getRule();
	}

	//GEqualityExpression returns GExpression:
	//	GRelationExpression ({GEqualityExpression.leftOperand=current} operator=GEqualityOperator
	//	rightOperand=GRelationExpression)*;
	public GExpressionsGrammarAccess.GEqualityExpressionElements getGEqualityExpressionAccess() {
		return gaGExpressions.getGEqualityExpressionAccess();
	}
	
	public ParserRule getGEqualityExpressionRule() {
		return getGEqualityExpressionAccess().getRule();
	}

	//GRelationExpression returns GExpression:
	//	GAdditionExpression ({GRelationExpression.leftOperand=current} operator=GRelationOperator
	//	rightOperand=GAdditionExpression)*;
	public GExpressionsGrammarAccess.GRelationExpressionElements getGRelationExpressionAccess() {
		return gaGExpressions.getGRelationExpressionAccess();
	}
	
	public ParserRule getGRelationExpressionRule() {
		return getGRelationExpressionAccess().getRule();
	}

	//GAdditionExpression returns GExpression:
	//	GMultiplicationExpression ({GAdditionExpression.leftOperand=current} operator=GAdditionOperator
	//	rightOperand=GMultiplicationExpression)*;
	public GExpressionsGrammarAccess.GAdditionExpressionElements getGAdditionExpressionAccess() {
		return gaGExpressions.getGAdditionExpressionAccess();
	}
	
	public ParserRule getGAdditionExpressionRule() {
		return getGAdditionExpressionAccess().getRule();
	}

	//GMultiplicationExpression returns GExpression:
	//	GNegationExpression ({GMultiplicationExpression.leftOperand=current} operator=GMultiplicationOperator
	//	rightOperand=GNegationExpression)*;
	public GExpressionsGrammarAccess.GMultiplicationExpressionElements getGMultiplicationExpressionAccess() {
		return gaGExpressions.getGMultiplicationExpressionAccess();
	}
	
	public ParserRule getGMultiplicationExpressionRule() {
		return getGMultiplicationExpressionAccess().getRule();
	}

	//GNegationExpression returns GExpression:
	//	GNavigationExpression | {GNegationExpression} operator=GNegationOperator operand=GNavigationExpression;
	public GExpressionsGrammarAccess.GNegationExpressionElements getGNegationExpressionAccess() {
		return gaGExpressions.getGNegationExpressionAccess();
	}
	
	public ParserRule getGNegationExpressionRule() {
		return getGNegationExpressionAccess().getRule();
	}

	//GNavigationExpression returns GExpression:
	//	GReferenceExpression ({GNavigationExpression.body=current} NavigationOperator referencedEObject=[ecore::EObject])*;
	public GExpressionsGrammarAccess.GNavigationExpressionElements getGNavigationExpressionAccess() {
		return gaGExpressions.getGNavigationExpressionAccess();
	}
	
	public ParserRule getGNavigationExpressionRule() {
		return getGNavigationExpressionAccess().getRule();
	}

	//GReferenceExpression returns GExpression:
	//	GPrimaryExpression | {GReferenceExpression} referencedEObject=[ecore::EObject];
	public GExpressionsGrammarAccess.GReferenceExpressionElements getGReferenceExpressionAccess() {
		return gaGExpressions.getGReferenceExpressionAccess();
	}
	
	public ParserRule getGReferenceExpressionRule() {
		return getGReferenceExpressionAccess().getRule();
	}

	////-----------------------------------------------------------------------------
	//// Primary expressions
	////-----------------------------------------------------------------------------
	//GPrimaryExpression returns GExpression:
	//	GStringExpression | GBooleanExpression | GNumericExpression | GEnumLiteralExpression | GIfExpression |
	//	GBraceExpression;
	public GExpressionsGrammarAccess.GPrimaryExpressionElements getGPrimaryExpressionAccess() {
		return gaGExpressions.getGPrimaryExpressionAccess();
	}
	
	public ParserRule getGPrimaryExpressionRule() {
		return getGPrimaryExpressionAccess().getRule();
	}

	//GStringExpression returns GExpression:
	//	{GStringExpression} value=STRING;
	public GExpressionsGrammarAccess.GStringExpressionElements getGStringExpressionAccess() {
		return gaGExpressions.getGStringExpressionAccess();
	}
	
	public ParserRule getGStringExpressionRule() {
		return getGStringExpressionAccess().getRule();
	}

	//GBooleanExpression returns GExpression:
	//	{GBooleanExpression} value=BOOLEAN;
	public GExpressionsGrammarAccess.GBooleanExpressionElements getGBooleanExpressionAccess() {
		return gaGExpressions.getGBooleanExpressionAccess();
	}
	
	public ParserRule getGBooleanExpressionRule() {
		return getGBooleanExpressionAccess().getRule();
	}

	//GNumericExpression returns GExpression:
	//	GIntegerExpression | GDoubleExpression;
	public GExpressionsGrammarAccess.GNumericExpressionElements getGNumericExpressionAccess() {
		return gaGExpressions.getGNumericExpressionAccess();
	}
	
	public ParserRule getGNumericExpressionRule() {
		return getGNumericExpressionAccess().getRule();
	}

	//GIntegerExpression returns GExpression:
	//	{GIntegerExpression} value=INT;
	public GExpressionsGrammarAccess.GIntegerExpressionElements getGIntegerExpressionAccess() {
		return gaGExpressions.getGIntegerExpressionAccess();
	}
	
	public ParserRule getGIntegerExpressionRule() {
		return getGIntegerExpressionAccess().getRule();
	}

	//GDoubleExpression returns GExpression:
	//	{GDoubleExpression} value=DOUBLE;
	public GExpressionsGrammarAccess.GDoubleExpressionElements getGDoubleExpressionAccess() {
		return gaGExpressions.getGDoubleExpressionAccess();
	}
	
	public ParserRule getGDoubleExpressionRule() {
		return getGDoubleExpressionAccess().getRule();
	}

	//GEnumLiteralExpression returns GExpression:
	//	{GEnumLiteralExpression} "#" value=[ecore::EEnumLiteral|QualifiedName];
	public GExpressionsGrammarAccess.GEnumLiteralExpressionElements getGEnumLiteralExpressionAccess() {
		return gaGExpressions.getGEnumLiteralExpressionAccess();
	}
	
	public ParserRule getGEnumLiteralExpressionRule() {
		return getGEnumLiteralExpressionAccess().getRule();
	}

	//GIfExpression returns GExpression:
	//	{GIfExpression} "if" condition=GExpression "then" thenExpression=GExpression "else" elseExpression=GExpression
	//	"endif";
	public GExpressionsGrammarAccess.GIfExpressionElements getGIfExpressionAccess() {
		return gaGExpressions.getGIfExpressionAccess();
	}
	
	public ParserRule getGIfExpressionRule() {
		return getGIfExpressionAccess().getRule();
	}

	//GBraceExpression returns GExpression:
	//	{GBraceExpression} "(" innerExpression=GExpression ")";
	public GExpressionsGrammarAccess.GBraceExpressionElements getGBraceExpressionAccess() {
		return gaGExpressions.getGBraceExpressionAccess();
	}
	
	public ParserRule getGBraceExpressionRule() {
		return getGBraceExpressionAccess().getRule();
	}

	////-----------------------------------------------------------------------------
	//// Operators enumerations
	////-----------------------------------------------------------------------------
	//enum GAndOperator:
	//	AND="and";
	public GExpressionsGrammarAccess.GAndOperatorElements getGAndOperatorAccess() {
		return gaGExpressions.getGAndOperatorAccess();
	}
	
	public EnumRule getGAndOperatorRule() {
		return getGAndOperatorAccess().getRule();
	}

	//enum GXorOperator:
	//	XOR="xor";
	public GExpressionsGrammarAccess.GXorOperatorElements getGXorOperatorAccess() {
		return gaGExpressions.getGXorOperatorAccess();
	}
	
	public EnumRule getGXorOperatorRule() {
		return getGXorOperatorAccess().getRule();
	}

	//enum GOrOperator:
	//	OR="or";
	public GExpressionsGrammarAccess.GOrOperatorElements getGOrOperatorAccess() {
		return gaGExpressions.getGOrOperatorAccess();
	}
	
	public EnumRule getGOrOperatorRule() {
		return getGOrOperatorAccess().getRule();
	}

	//enum GEqualityOperator:
	//	EQUAL="=" | NOTEQUAL="<>";
	public GExpressionsGrammarAccess.GEqualityOperatorElements getGEqualityOperatorAccess() {
		return gaGExpressions.getGEqualityOperatorAccess();
	}
	
	public EnumRule getGEqualityOperatorRule() {
		return getGEqualityOperatorAccess().getRule();
	}

	//enum GRelationOperator:
	//	LESS="<" | GREATER=">" | LESSEQUAL="<=" | GREATEREQUAL=">=";
	public GExpressionsGrammarAccess.GRelationOperatorElements getGRelationOperatorAccess() {
		return gaGExpressions.getGRelationOperatorAccess();
	}
	
	public EnumRule getGRelationOperatorRule() {
		return getGRelationOperatorAccess().getRule();
	}

	//enum GAdditionOperator:
	//	ADDITION="+" | SUBTRACTION="-";
	public GExpressionsGrammarAccess.GAdditionOperatorElements getGAdditionOperatorAccess() {
		return gaGExpressions.getGAdditionOperatorAccess();
	}
	
	public EnumRule getGAdditionOperatorRule() {
		return getGAdditionOperatorAccess().getRule();
	}

	//enum GMultiplicationOperator:
	//	MULTIPLICATION="*" | DIVISION="/";
	public GExpressionsGrammarAccess.GMultiplicationOperatorElements getGMultiplicationOperatorAccess() {
		return gaGExpressions.getGMultiplicationOperatorAccess();
	}
	
	public EnumRule getGMultiplicationOperatorRule() {
		return getGMultiplicationOperatorAccess().getRule();
	}

	//enum GNegationOperator:
	//	NEGATION="not" | MINUS= // TODO: fix unary negation
	//	"~";
	public GExpressionsGrammarAccess.GNegationOperatorElements getGNegationOperatorAccess() {
		return gaGExpressions.getGNegationOperatorAccess();
	}
	
	public EnumRule getGNegationOperatorRule() {
		return getGNegationOperatorAccess().getRule();
	}

	////-----------------------------------------------------------------------------
	//// Additional terminals
	////-----------------------------------------------------------------------------
	//NavigationOperator returns ecore::EString:
	//	"." | "->";
	public GExpressionsGrammarAccess.NavigationOperatorElements getNavigationOperatorAccess() {
		return gaGExpressions.getNavigationOperatorAccess();
	}
	
	public ParserRule getNavigationOperatorRule() {
		return getNavigationOperatorAccess().getRule();
	}

	//terminal BOOLEAN returns ecore::EBoolean:
	//	"true" | "false";
	public TerminalRule getBOOLEANRule() {
		return gaGExpressions.getBOOLEANRule();
	} 

	//terminal DOUBLE returns ecore::EDouble:
	//	("-" | "+")? (INT "." INT | "." INT | INT ".") ("e" ("-" | "+") INT)?;
	public TerminalRule getDOUBLERule() {
		return gaGExpressions.getDOUBLERule();
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaGExpressions.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaGExpressions.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" . / * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\""))* "\"" | "\'" ("\\" .
	//	/ * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaGExpressions.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaGExpressions.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaGExpressions.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaGExpressions.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaGExpressions.getANY_OTHERRule();
	} 
}
